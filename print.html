<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js geo-engine">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Geo Engine Docs</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "geo-engine" : "geo-engine";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('geo-engine')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            
            <div class="sidebar-scrollbox">
                <!-- TODO: Replace with standard functionality: https://github.com/rust-lang/mdBook/pull/1584 -->
                <div class="sidebar-book-logo">
                    <img src="images/GeoEngine_Mainlogo.png" alt="Geo Engine">
                </div>
                <ol class="chapter"><li class="chapter-item expanded "><a href="welcome.html"><strong aria-hidden="true">1.</strong> Welcome to Geo Engine Docs</a></li><li class="chapter-item expanded "><a href="geoengine/intro.html"><strong aria-hidden="true">2.</strong> The Geo Engine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="geoengine/datasets.html"><strong aria-hidden="true">2.1.</strong> Datasets</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Engine</div></li><li class="chapter-item expanded "><a href="geoengine/layers.html"><strong aria-hidden="true">2.3.</strong> Layers</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> Workflows</div></li></ol></li><li class="chapter-item expanded "><a href="pro/intro.html"><strong aria-hidden="true">3.</strong> Pro Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pro/users.html"><strong aria-hidden="true">3.1.</strong> Users and Permissions</a></li></ol></li><li class="chapter-item expanded "><a href="api/intro.html"><strong aria-hidden="true">4.</strong> API</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Datasets</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Projects</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Upload</div></li><li class="chapter-item expanded "><a href="api/workflows.html"><strong aria-hidden="true">4.4.</strong> Workflows</a></li></ol></li><li class="chapter-item expanded "><a href="datatypes/intro.html"><strong aria-hidden="true">5.</strong> Datatypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="datatypes/colorizer.html"><strong aria-hidden="true">5.1.</strong> Colorizer</a></li><li class="chapter-item expanded "><a href="datatypes/measurement.html"><strong aria-hidden="true">5.2.</strong> Measurement</a></li><li class="chapter-item expanded "><a href="datatypes/queryrectangle.html"><strong aria-hidden="true">5.3.</strong> QueryRectangle</a></li><li class="chapter-item expanded "><a href="datatypes/rasterbanddescriptor.html"><strong aria-hidden="true">5.4.</strong> RasterBandDescriptor</a></li><li class="chapter-item expanded "><a href="datatypes/rasterdatatype.html"><strong aria-hidden="true">5.5.</strong> RasterDataType</a></li><li class="chapter-item expanded "><a href="datatypes/timeinstance.html"><strong aria-hidden="true">5.6.</strong> TimeInstance</a></li><li class="chapter-item expanded "><a href="datatypes/timeinterval.html"><strong aria-hidden="true">5.7.</strong> TimeInterval</a></li><li class="chapter-item expanded "><a href="datatypes/timestep.html"><strong aria-hidden="true">5.8.</strong> TimeStep</a></li></ol></li><li class="chapter-item expanded "><a href="operators/intro.html"><strong aria-hidden="true">6.</strong> Operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="operators/columnrangefilter.html"><strong aria-hidden="true">6.1.</strong> ColumnRangeFilter</a></li><li class="chapter-item expanded "><a href="operators/expression.html"><strong aria-hidden="true">6.2.</strong> Expression</a></li><li class="chapter-item expanded "><a href="operators/gdalsource.html"><strong aria-hidden="true">6.3.</strong> GdalSource</a></li><li class="chapter-item expanded "><a href="operators/interpolation.html"><strong aria-hidden="true">6.4.</strong> Interpolation</a></li><li class="chapter-item expanded "><a href="operators/linesimplification.html"><strong aria-hidden="true">6.5.</strong> LineSimplification</a></li><li class="chapter-item expanded "><a href="operators/neighborhoodaggregate.html"><strong aria-hidden="true">6.6.</strong> NeighborhoodAggregate</a></li><li class="chapter-item expanded "><a href="operators/ogrsource.html"><strong aria-hidden="true">6.7.</strong> OgrSource</a></li><li class="chapter-item expanded "><a href="operators/pointinpolygon.html"><strong aria-hidden="true">6.8.</strong> PointInPolygon</a></li><li class="chapter-item expanded "><a href="operators/rasterization.html"><strong aria-hidden="true">6.9.</strong> Rasterization</a></li><li class="chapter-item expanded "><a href="operators/rasterscaling.html"><strong aria-hidden="true">6.10.</strong> RasterScaling</a></li><li class="chapter-item expanded "><a href="operators/rasterstacker.html"><strong aria-hidden="true">6.11.</strong> RasterStacker</a></li><li class="chapter-item expanded "><a href="operators/rastertypeconversion.html"><strong aria-hidden="true">6.12.</strong> RasterTypeConversion</a></li><li class="chapter-item expanded "><a href="operators/rastervectorjoin.html"><strong aria-hidden="true">6.13.</strong> RasterVectorJoin</a></li><li class="chapter-item expanded "><a href="operators/reprojection.html"><strong aria-hidden="true">6.14.</strong> Reprojection</a></li><li class="chapter-item expanded "><a href="operators/rgb.html"><strong aria-hidden="true">6.15.</strong> RGB</a></li><li class="chapter-item expanded "><a href="operators/temporalrasteraggregation.html"><strong aria-hidden="true">6.16.</strong> TemporalRasterAggregation</a></li><li class="chapter-item expanded "><a href="operators/timeprojection.html"><strong aria-hidden="true">6.17.</strong> TimeProjection</a></li><li class="chapter-item expanded "><a href="operators/timeshift.html"><strong aria-hidden="true">6.18.</strong> TimeShift</a></li><li class="chapter-item expanded "><a href="operators/vectorexpression.html"><strong aria-hidden="true">6.19.</strong> VectorExpression</a></li><li class="chapter-item expanded "><a href="operators/vectorjoin.html"><strong aria-hidden="true">6.20.</strong> VectorJoin</a></li><li class="chapter-item expanded "><a href="operators/visualpointclustering.html"><strong aria-hidden="true">6.21.</strong> VisualPointClustering</a></li></ol></li><li class="chapter-item expanded "><a href="plots/intro.html"><strong aria-hidden="true">7.</strong> Plots</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plots/boxplot.html"><strong aria-hidden="true">7.1.</strong> BoxPlot</a></li><li class="chapter-item expanded "><a href="plots/classHistogram.html"><strong aria-hidden="true">7.2.</strong> ClassHistogram</a></li><li class="chapter-item expanded "><a href="plots/featureattributevaluesoverTime.html"><strong aria-hidden="true">7.3.</strong> FeatureAttributeValuesOverTime</a></li><li class="chapter-item expanded "><a href="plots/histogram.html"><strong aria-hidden="true">7.4.</strong> Histogram</a></li><li class="chapter-item expanded "><a href="plots/meanrasterpixelvaluesovertime.html"><strong aria-hidden="true">7.5.</strong> MeanRasterPixelValuesOverTime</a></li><li class="chapter-item expanded "><a href="plots/piechart.html"><strong aria-hidden="true">7.6.</strong> PieChart</a></li><li class="chapter-item expanded "><a href="plots/scatterplot.html"><strong aria-hidden="true">7.7.</strong> ScatterPlot</a></li><li class="chapter-item expanded "><a href="plots/statistics.html"><strong aria-hidden="true">7.8.</strong> Statistics</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> OGC Access</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> WMS</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Solutions</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Geo Engine Pro</div></li></ol></li></ol>                <ol class="chapter">
                    <li class="part-title">API Reference</li>
                    <li class="chapter-item">
                        <a href="https://python.docs.geoengine.io" style="width: 100%; display: flex; flex-direction: row;">
                            <span style="flex: 1;">Python</span>
                            <i class="fa fa-external-link" style="align-self: center;"></i>
                        </a>
                    </li>
                </ol>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <!-- TODO: include back if we have a dark theme -->
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list" style="display: none;">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Geo Engine Docs</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-geo-engine-docs"><a class="header" href="#welcome-to-geo-engine-docs">Welcome to Geo Engine Docs</a></h1>
<p>Geo Engine is a cloud-ready geo-spatial data processing platform.
This documentation presents the foundations of the system and how to use it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-geo-engine"><a class="header" href="#the-geo-engine">The Geo Engine</a></h1>
<p>Geo Engine is a cloud-ready geospatial data processing platform.
Here, we give an overview of its architecture and describe the main components.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<!--
Take from Google Slide…
 - export as SVG,
 - Crop with Inkscape,
 - and scale x2.
-->
<p><img src="geoengine/../images/architecture.svg" alt="Architecture" /></p>
<p>Geo Engine consists of the backend and several frontends.
The backend is subdivided into three subcomponents: services, operators, and data types.
Data types specify primitives like feature collections for vector or gridded raster data.
Moreover, it defines plots and basic operations, e.g., projections.
The <code>Operators</code> block contains the processing engine and operators, i.e., source operators, raster- and vector time series processing.
Furthermore, there are raster time series stream adapters, which can be used as building blocks for operators.
The <code>Services</code> block contains protocols, e.g., OGC standard interfaces, as well as Geo Engine specific interfaces.
These can be workflow registration, plot queries, and data upload.
Each of the subcomponents can have additions in Geo Engine Pro, for instance, User Management, which is only available in Geo Engine Pro.</p>
<p>Frontends for the Geo Engine are <code>geoengine-ui</code> for building web applications on top of Geo Engine.
<code>geoengine-python</code> offers a Python library that can be used in Jupyter Notebooks.
3rd party applications like QGIS can access Geo Engine via its OGC interfaces.</p>
<p>All components of Geo Engine are fully containerized and Docker-ready.
Geo Engine builds upon several technologies, including GDAL, arrow, Angular, and OpenLayers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datasets"><a class="header" href="#datasets">Datasets</a></h1>
<p>A dataset is a loadable unit in Geo Engine.
It is a parameter of a source operator (e.g., a <a href="geoengine/../operators/gdalsource.html"><code>GdalSource</code></a>) and identifies the data that is loaded.
Geo Engine supports different types of data, reflected by a <code>DataId</code>, which refers to internal datasets and external data.</p>
<h2 id="internal-dataset"><a class="header" href="#internal-dataset">Internal dataset</a></h2>
<p>An internal dataset is a dataset that is stored in the Geo Engine.
Thus, it is efficiently accessible and can be used in workflows.
The dataset is identified by a <code>DatasetName</code> and contains a <code>DatasetDefinition</code> that describes the data.</p>
<p>The <code>DatasetName</code> is a string that consists of a <em>namespace</em> (optional) and a <em>name</em>, separated by a colon.
For instance, <code>namespace:name</code> or <code>name</code> refer to datasets.
The <code>name</code> can consist of characters (<code>a-Z</code> &amp; <code>A-Z</code>), numbers (<code>0-9</code>), dashes (<code>-</code>) and underscores (<code>_</code>).</p>
<h2 id="external-data"><a class="header" href="#external-data">External data</a></h2>
<p>An external dataset is a dataset that is not stored in the Geo Engine.
Geo Engine accesses it from a foreign location.
The dataset is identified by an <code>ExternalDataId</code> that consists of a <code>DataProviderId</code> and a <code>LayerId</code>.
While the <code>DatasetProviderId</code> is usually a UUID that identifies the data provider for Geo Engine itself, the <code>LayerId</code> is a string that identifies the layer in the data provider.</p>
<p>The <code>ExternalDataId</code> is a string that consists of a <em>namespace</em>, the <code>DataProviderId</code> and a <em>name</em>, separated by a colon.
The namespace cannot be omitted and is <code>_</code> for the global namespace.
For instance, <code>_:{uuid}:name</code> or <code>namespace:{uuid}:name</code> refer to datasets.
If the <em>name</em> is a complex string, it can be enclosed by backticks, e.g., <code>namespace:{uuid}:`name with spaces`</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layers"><a class="header" href="#layers">Layers</a></h1>
<!-- TODO: Link to workflow section in `/geoengine` rather than `/api` when available -->
<p>A layer is a browsable unit in Geo Engine.
In general, it is a named <a href="geoengine/../api/workflows.html"><code>Workflow</code></a> with additional meta information like a description and a default <a href="geoengine/../datatypes/colorizer.html"><code>Colorizer</code></a>.
Layers are identified by a <code>LayerId</code>, which is usually a UUID.
Every layer can be part of one or more <a href="geoengine/./layers.html#layer-collections"><code>Layer collections</code></a>.</p>
<h2 id="layer-collections"><a class="header" href="#layer-collections">Layer collections</a></h2>
<p>Layer collections are groups of <a href="geoengine/./layers.html"><code>Layers</code></a>.
The collections themselves can be grouped inside other collections.
Every layer collection has a name and a description.
Layer collections, just like layers, can be part of one or more other layer collections.</p>
<h2 id="browsing"><a class="header" href="#browsing">Browsing</a></h2>
<p>Inside Geo Engine's web interface, you can browse the available layers and layer collections when adding data.</p>
<p>Inside Python, you can use the</p>
<pre><code class="language-python">ge.layer_collection()
</code></pre>
<p>function to get a list of the root collection which contains paths to all underlying layers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pro-features"><a class="header" href="#pro-features">Pro Features</a></h1>
<p>While much of Geo Engine's functionality is Open Source and freely usable, some parts are only available in the Pro version.
To use the Pro version, you need to purchase a Pro license.
You may, however, be eligible for a free academic license.
Please contact us at <a href="mailto:info@geoengine.de?subject=Academic%20License">info@geoengine.de</a> to request one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="users-and-permission"><a class="header" href="#users-and-permission">Users and Permission</a></h1>
<p>The Pro version of Geo Engine includes a user management system.
Users can either be <em>anonymous</em> or <em>registered</em>.
On the first startup, an admin user will be created.</p>
<p>Geo Engine has a Role Based Access Control (RBAC) system.
Users can have different roles and permissions on resources are granted to these roles.
By default, they have a unique role for themselves and either the role <code>anonymous</code> or <code>registered</code>.
The admin user has the role <code>admin</code>.</p>
<p>Geo Engine allows defining permissions for resources like Datasets, Workflows, Layers and Projects.
When a resource is created, the creator gets the <code>Owner</code> permission.
This means they can do everything with the resource, including deleting it and permitting others to use it.
For read-only access, the <code>Read</code> permission is available.
The management of the permissions is done via the Permissions API.
Admin users, i.e. users with the role <code>admin</code> assigned to them, can create new roles and assign them to users.
The management of roles is also done via the Permissions API.
Please refer to the API documentation (TODO: link) for more information.
Alternatively, you can also use our Python library to manage permissions.
Please refer to the <a href="https://python.docs.geoengine.io/">Python library documentation</a> for more information.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let's say Alice creates a project P.
She automatically gets the <code>Owner</code> permission assigned on the project to her user role.
Then, she adds a <code>Read</code> permission for User Bob.
Before the permission is added, the system checks for the <code>Owner</code> permission on project P.
As Alice is the owner, this operation succeeds.
When Bob tries to access the project P the system checks for the <code>Read</code> permission which again succeeds.</p>
<p>Alice now wants to grant Charly and and Dave the <code>Read</code> permission as well.
Both Charly and Dave have the role <code>Friends of Alice</code>.
She decides to give the permission to the role instead of both users individually.
Both Charly and Dave can now access project P, but Mallory, who does not have the role gets a <code>PermissionDenied</code> error.
When later on Erin gets the role R assigned, she automatically gains access to project P as well.</p>
<p>The complete permission scenario looks like this</p>
<ul>
<li>Resources
<ul>
<li>project P</li>
</ul>
</li>
<li>Users
<ul>
<li>Alice</li>
<li>Bob</li>
<li>Charly</li>
<li>Dave</li>
<li>Erin</li>
<li>Mallory</li>
</ul>
</li>
<li>Permissions (Role, Resource, Permission)
<ul>
<li>Alice, project P, Owner</li>
<li>Bob, project P, Read</li>
<li>Friends of Alice, project P, Read</li>
</ul>
</li>
<li>Roles
<ul>
<li>User roles (omitted)</li>
<li>Friends of Alice
<ul>
<li>Charly</li>
<li>Dave</li>
</ul>
</li>
</ul>
</li>
<li>Read access allowed
<ul>
<li>Alice</li>
<li>Bob</li>
<li>Charly</li>
<li>Dave</li>
<li>Erin</li>
</ul>
</li>
<li>Read access denied
<ul>
<li>Mallory</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<p>This chapter introduces the API of Geo Engine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workflows"><a class="header" href="#workflows">Workflows</a></h1>
<p>This section introduces the workflow API of Geo Engine.</p>
<h2 id="resultdescriptor"><a class="header" href="#resultdescriptor">ResultDescriptor</a></h2>
<p>Call <code>/workflow/{workflowId}/metadata</code> to get the result descriptor of the workflow. It describes the result of the workflow by data type, spatial reference, temporal and spatial extent and some more information that is specific to raster and vector results.</p>
<h3 id="example-response-for-rasters"><a class="header" href="#example-response-for-rasters">Example response for rasters</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;raster&quot;,
  &quot;dataType&quot;: &quot;U8&quot;,
  &quot;spatialReference&quot;: &quot;EPSG:4326&quot;,
  &quot;measurement&quot;: {
    &quot;type&quot;: &quot;unitless&quot;
  },
  &quot;time&quot;: {
    &quot;start&quot;: &quot;2014-01-01T00:00:00.000Z&quot;,
    &quot;end&quot;: &quot;2014-07-01T00:00:00.000Z&quot;
  },
  &quot;bbox&quot;: {
    &quot;upperLeftCoordinate&quot;: [-180.0, 90.0],
    &quot;lowerRightCoordinate&quot;: [180.0, -90.0]
  }
}
</code></pre>
<h3 id="example-response-for-vectors"><a class="header" href="#example-response-for-vectors">Example response for vectors</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;vector&quot;,
  &quot;dataType&quot;: &quot;MultiPoint&quot;,
  &quot;spatialReference&quot;: &quot;EPSG:4326&quot;,
  &quot;columns&quot;: {
    &quot;id&quot;: &quot;int&quot;,
    &quot;name&quot;: &quot;text&quot;,
    &quot;value&quot;: &quot;float&quot;
  },
  &quot;time&quot;: {
    &quot;start&quot;: &quot;2014-04-01T00:00:00.000Z&quot;,
    &quot;end&quot;: &quot;2014-07-01T00:00:00.000Z&quot;
  },
  &quot;bbox&quot;: {
    &quot;lowerLeftCoordinate&quot;: [3.9662060000000001, 45.9030360000000002],
    &quot;upperRightCoordinate&quot;: [19.171284, 51.8473430000000022]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datatypes"><a class="header" href="#datatypes">Datatypes</a></h1>
<p>This chapter introduces the datatypes of Geo Engine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colorizer"><a class="header" href="#colorizer">Colorizer</a></h1>
<p>A colorizer specifies a mapping between values and pixels/objects of an output image.
Different variants of colorizers perform different kinds of mapping.
In general, there are two families of colorizers: <strong><em>gradient</em></strong> and <strong><em>palette</em></strong>.
<em>Gradients</em> are used to interpolate a continuous spectrum of colors between explicitly stated tuples (<code>breakpoints</code>) of a value and a color.
A <code>palette</code> colorizer on the other hand, is used to generate a discrete set of colors, each mapped to a specific value.</p>
<p>There are three miscellaneous fields in both of the gradient colorizers, namely <code>noDataColor</code>, <code>overColor</code> and <code>underColor</code>.
The field <code>noDataColor</code> is used for all missing, <code>NaN</code> or no data values.
The fields <code>overColor</code> and <code>underColor</code> are used for all overflowing values.
For instance, if there are breakpoints defined from <code>0</code> to <code>10</code>, but a value of <code>-5</code> or <code>11</code> is mapped to a color, the respective field will be chosen instead.
This way, you can specifically highlight values that lie outside of a given range.</p>
<p>For a <code>palette</code> colorizer, there are no <code>overColor</code> and <code>underColor</code> fields.
If a given value does not match any entry in the palette's definition, it is mapped to the <code>defaultColor</code>.
The <code>noDataColor</code> works in the same manner as in the <em>gradiant</em> variants.</p>
<p>Colors are defined as RGBA arrays, where the first three values refer to red, green and blue and the fourth one to alpha, which means transparency.
The values range from <code>0</code> to <code>255</code>.
For instance, <code>[255, 255, 255, 255]</code> is opaque white and <code>[0, 0, 0, 127]</code> is semi-transparent black.</p>
<h2 id="linear-gradient"><a class="header" href="#linear-gradient">Linear Gradient</a></h2>
<p>A linear gradient linearly interpolates values within breakpoints of a color table.
For instance, the example below is showing a gradient representing the physical conditions of water at different temperatures.
The gradient is defined between <code>0.0</code> and <code>99.99</code>, where <code>0.0</code> is shown as a light blue and <code>99.99</code> as blue.
Any value less than <code>0.0</code>, hence being ice, is shown as white.
Values above <code>99.99</code> are shown as a light gray.</p>
<h3 id="example-json"><a class="header" href="#example-json">Example JSON</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;linearGradient&quot;,
  &quot;breakpoints&quot;: [
    {
      &quot;value&quot;: 0.0,
      &quot;color&quot;: [204, 229, 255, 255]
    },
    {
      &quot;value&quot;: 99.99,
      &quot;color&quot;: [0, 0, 255, 255]
    }
  ],
  &quot;noDataColor&quot;: [0, 0, 0, 0],
  &quot;overColor&quot;: [224, 224, 224, 255],
  &quot;underColor&quot;: [255, 255, 255, 255]
}
</code></pre>
<h2 id="logarithmic-gradient"><a class="header" href="#logarithmic-gradient">Logarithmic Gradient</a></h2>
<p>A logarithmic gradient logarithmically interpolates values within breakpoints of a color table and allows only positive values.
This colorizer is particularly useful in situations,
where the data values increase exponentially and minor changes in the lower numbers would not be recognizable anymore.</p>
<h3 id="errors"><a class="header" href="#errors">Errors</a></h3>
<p>Services report errors that try to use a logarithmic gradient specification with values where <code>value &lt;= 0</code>.</p>
<h3 id="example-json-1"><a class="header" href="#example-json-1">Example JSON</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;logarithmicGradient&quot;,
  &quot;breakpoints&quot;: [
    {
      &quot;value&quot;: 1.0,
      &quot;color&quot;: [255, 255, 255, 255]
    },
    {
      &quot;value&quot;: 100.0,
      &quot;color&quot;: [0, 0, 0, 255]
    }
  ],
  &quot;noDataColor&quot;: [0, 0, 0, 0],
  &quot;overColor&quot;: [0, 0, 0, 255],
  &quot;underColor&quot;: [255, 255, 255, 255]
}
</code></pre>
<h2 id="palette"><a class="header" href="#palette">Palette</a></h2>
<p>A palette maps values as classes to a certain color.
Unmapped values result in the <code>defaultColor</code>.</p>
<h3 id="example-json-2"><a class="header" href="#example-json-2">Example JSON</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;palette&quot;,
  &quot;colors&quot;: {
    &quot;1&quot;: [255, 255, 255, 255],
    &quot;2&quot;: [0, 0, 0, 255]
  },
  &quot;noDataColor&quot;: [0, 0, 0, 0],
  &quot;defaultColor&quot;: [0, 0, 0, 0]
}
</code></pre>
<h2 id="rgba"><a class="header" href="#rgba">RGBA</a></h2>
<p>The RGBA colorizer maps <code>U32</code> values &quot;as is&quot; to RGBA colors.
8 and 16 bit values are interpreted as grayscale colors.
64 bit values are interpreted as RGBA colors (but loose precision).</p>
<h3 id="example-json-3"><a class="header" href="#example-json-3">Example JSON</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;rgba&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="measurement"><a class="header" href="#measurement">Measurement</a></h1>
<p>Measurements describe stored data, i.e. what is measured and in which unit.</p>
<h2 id="unitless"><a class="header" href="#unitless">Unitless</a></h2>
<p>Some values do not have an associated measurement or no information is present.</p>
<h3 id="example-json-4"><a class="header" href="#example-json-4">Example JSON</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;unitless&quot;
}
</code></pre>
<h2 id="continuous"><a class="header" href="#continuous">Continuous</a></h2>
<p>The type <code>continuous</code> specifies a continuous variable that is measured in a certain unit.</p>
<h3 id="example-json-5"><a class="header" href="#example-json-5">Example JSON</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;continuous&quot;,
  &quot;measurement&quot;: &quot;Reflectance&quot;,
  &quot;unit&quot;: &quot;%&quot;
}
</code></pre>
<h2 id="classification"><a class="header" href="#classification">Classification</a></h2>
<p>A classification maps numbers to named classes.</p>
<h3 id="example-json-6"><a class="header" href="#example-json-6">Example JSON</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;classification&quot;,
  &quot;measurement&quot;: &quot;Land Cover&quot;,
  &quot;classes&quot;: {
    &quot;0&quot;: &quot;Grassland&quot;,
    &quot;1&quot;: &quot;Forest&quot;,
    &quot;2&quot;: &quot;Water&quot;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queryrectangle"><a class="header" href="#queryrectangle">QueryRectangle</a></h1>
<p>A query rectangle defines a multi-dimensional spatial query in Geo Engine.
It consists of three parts:</p>
<ul>
<li>a two-dimensional spatial bounds (and extent plus its spatial reference system),</li>
<li>a time interval,</li>
<li>a spatial resolution.</li>
</ul>
<p>The spatial bounds behave differently for raster, vector, or plot queries.
For raster queries, the spatial bounds define a spatial partition.
This means the lower right corner of the spatial bounds is not included in the query.
For vector queries, the spatial bounds define a bounding box, i.e., a rectangle where all bounds are included.
Plot queries behave like vector queries.</p>
<h1 id="example-json-7"><a class="header" href="#example-json-7">Example JSON</a></h1>
<pre><code class="language-json">{
  &quot;spatial_bounds&quot;: {
    &quot;upper_left_coordinate&quot;: {
      &quot;x&quot;: 10.0,
      &quot;y&quot;: 20.0
    },
    &quot;lower_right_coordinate&quot;: {
      &quot;x&quot;: 70.0,
      &quot;y&quot;: 80.0
    }
  },
  &quot;time_interval&quot;: {
    &quot;start&quot;: &quot;2010-01-01T00:00:00Z&quot;,
    &quot;end&quot;: &quot;2011-01-01T00:00:00Z&quot;
  },
  &quot;spatial_resolution&quot;: {
    &quot;x&quot;: 1.0,
    &quot;y&quot;: 1.0
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rasterbanddescriptor"><a class="header" href="#rasterbanddescriptor">RasterBandDescriptor</a></h1>
<p>A raster band descriptor describes a single band of a raster source.
The description contains a name and a <a href="datatypes//datatypes/measurement.html">Measurement</a>.</p>
<h2 id="example-json-8"><a class="header" href="#example-json-8">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;NDVI&quot;,
  &quot;measurement&quot;: {
    &quot;type&quot;: &quot;continuous&quot;,
    &quot;unit&quot;: &quot;NDVI&quot;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raster-data-type"><a class="header" href="#raster-data-type">Raster Data Type</a></h1>
<p>Rasters can have the following data types:</p>
<ul>
<li>U8: unsigned 8-bit integer</li>
<li>I8: signed 8-bit integer</li>
<li>U16: unsigned 16-bit integer</li>
<li>I16: signed 16-bit integer</li>
<li>U32: unsigned 32-bit integer</li>
<li>I32: signed 32-bit integer</li>
<li>U64: unsigned 64-bit integer</li>
<li>I64: signed 64-bit integer</li>
<li>F32: 32-bit floating-point</li>
<li>F64: 64-bit floating-point</li>
</ul>
<h1 id="example-json-9"><a class="header" href="#example-json-9">Example JSON</a></h1>
<pre><code class="language-json">&quot;U8&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-instance"><a class="header" href="#time-instance">Time Instance</a></h1>
<p>A time instance is a single point in time.
It is specified in UTC time zone 0 and has a maximum resolution of milliseconds.</p>
<h1 id="example-json-10"><a class="header" href="#example-json-10">Example JSON</a></h1>
<p>Specifying in ISO 8601:</p>
<pre><code class="language-json">&quot;2010-01-01T00:00:00Z&quot;
</code></pre>
<p>Using the same date as a UNIX timestamp in milliseconds:</p>
<pre><code class="language-json">1262304000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-interval"><a class="header" href="#time-interval">Time Interval</a></h1>
<p>A time interval consists of two <a href="datatypes/./timeinstance.html"><code>TimeInstance</code>s</a>.
Please be aware, that the interval is defined in close-open semantics.
This means, that the start time is inclusive and the end time of the interval is exclusive.
In mathematical notation, the interval is defined as <code>[start, end)</code>.</p>
<h1 id="example-json-11"><a class="header" href="#example-json-11">Example JSON</a></h1>
<p>Specifying in ISO 8601:</p>
<pre><code class="language-json">{
  &quot;start&quot;: &quot;2010-01-01T00:00:00Z&quot;,
  &quot;end&quot;: &quot;2011-01-01T00:00:00Z&quot;
}
</code></pre>
<p>Using the same date as UNIX timestamps in milliseconds:</p>
<pre><code class="language-json">{
  &quot;start&quot;: 1262304000000,
  &quot;end&quot;: 1293840000000
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-step"><a class="header" href="#time-step">Time Step</a></h1>
<p>A time step consists of granularity and the number of steps.
For instance, you can specify yearly steps by settings the granularity to <code>Years</code> and the number of steps to 1.
Half-yearly steps can be specified by setting the granularity to <code>Months</code> and the number of steps to 6.</p>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>granularity</code></td><td><code>TimeGranularity</code></td><td>granularity of the time steps</td><td><code>months</code></td></tr>
<tr><td><code>step</code></td><td><code>integer</code></td><td>number of time steps</td><td>1</td></tr>
</tbody></table>
<h2 id="timegranularity"><a class="header" href="#timegranularity">TimeGranularity</a></h2>
<p>The granularity of the time steps can take one of the following values.</p>
<table><thead><tr><th>Variant</th><th>Description</th></tr></thead><tbody>
<tr><td><code>millis</code></td><td>milliseconds</td></tr>
<tr><td><code>seconds</code></td><td>seconds</td></tr>
<tr><td><code>minutes</code></td><td>minutes</td></tr>
<tr><td><code>hours</code></td><td>hours</td></tr>
<tr><td><code>days</code></td><td>days</td></tr>
<tr><td><code>months</code></td><td>months</td></tr>
<tr><td><code>years</code></td><td>years</td></tr>
</tbody></table>
<h1 id="example-json-12"><a class="header" href="#example-json-12">Example JSON</a></h1>
<pre><code class="language-json">{
  &quot;granularity&quot;: &quot;months&quot;,
  &quot;step&quot;: 1
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>This chapter introduces the operators of Geo Engine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="columnrangefilter"><a class="header" href="#columnrangefilter">ColumnRangeFilter</a></h1>
<p>The <code>ColumnRangeFilter</code> operator allows filtering <code>FeatureCollection</code>s.
Users can define one or more data ranges for a column in the data table that is then filtered.
The filter can be used for numerical as well as textual columns.
Each range is inclusive, i.e., <code>[start, end]</code> includes as well the <code>start</code> as the <code>end</code>.</p>
<p>For instance, you can filter a collection to only include column values that are either in the range 0-10 or 20-30.
Moreover, you can specify the range <code>a</code> to <code>k</code> to dismiss all column values that start with larger letters in the alphabet.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>column</code></td><td>string</td><td>a column name of the <code>FeatureCollection</code></td><td><pre>&quot;precipitation&quot;</pre></td></tr>
<tr><td><code>ranges</code></td><td>List of either string or number ranges</td><td>one or more ranges of either strings or numbers; each range works as an <em>or</em> for the filter</td><td><pre>[[42,43]]</pre></td></tr>
<tr><td><code>keepNulls</code></td><td>boolean</td><td>should null values be kept or discarded?</td><td><pre>true</pre></td></tr>
</tbody></table>
<h2 id="inputs"><a class="header" href="#inputs">Inputs</a></h2>
<p>The <code>ColumnRangeFilter</code> operator expects exactly one <em>vector</em> input.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>vector</code></td><td><code>SingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-1"><a class="header" href="#errors-1">Errors</a></h2>
<p>If the value in the <code>column</code> parameter is not a column of the feature collection, an error is thrown.</p>
<h2 id="example-json-13"><a class="header" href="#example-json-13">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;ColumnRangeFilter&quot;,
  &quot;params&quot;: {
    &quot;column&quot;: &quot;population&quot;,
    &quot;ranges&quot;: [[1000, 10000]],
    &quot;keepNulls&quot;: false
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;places&quot;,
        &quot;attributeProjection&quot;: [&quot;name&quot;, &quot;population&quot;]
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;ColumnRangeFilter&quot;,
  &quot;params&quot;: {
    &quot;column&quot;: &quot;name&quot;,
    &quot;ranges&quot;: [
      [&quot;a&quot;, &quot;k&quot;],
      [&quot;v&quot;, &quot;z&quot;]
    ],
    &quot;keepNulls&quot;: false
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;places&quot;,
        &quot;attributeProjection&quot;: [&quot;name&quot;, &quot;population&quot;]
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raster-expression"><a class="header" href="#raster-expression">Raster Expression</a></h1>
<p>The <code>Expression</code> operator performs a pixel-wise mathematical expression on one or more bands of a raster source.
The expression is specified as a user-defined script in a very simple language.
The output is a raster time series with the result of the expression and with time intervals that are the same as for the inputs.
Users can specify an output data type.
Internally, the expression is evaluated using floating-point numbers.</p>
<p>An example usage scenario is to calculate NDVI for a red and a near-infrared raster channel.
The expression uses a raster source with two bands, referred to as A and B, and calculates the formula <code>(A - B) / (A + B)</code>.
When the temporal resolution is months, our output NDVI will also be a monthly time series.</p>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>expression</code></td><td><code>Expression</code></td><td>Expression script</td><td><pre><code>(A - B) / (A + B)</code></pre></td></tr>
<tr><td><code>outputType</code></td><td><a href="operators//datatypes/rasterdatatype.html"><code>RasterDataType</code></a></td><td>A raster data type for the output</td><td><pre><code>U8</code></pre></td></tr>
<tr><td><code>outputBand</code></td><td><a href="operators//datatypes/rasterbanddescriptor.html"><code>RasterBandDescriptor</code></a></td><td>Description about the output</td><td><pre><code>{<br>  &quot;name&quot;: &quot;NDVI&quot;<br>  &quot;measurement&quot;: {<br>    &quot;type&quot;: &quot;continuous&quot;,<br>     &quot;measurement&quot;: &quot;NDVI&quot;<br>  }<br>}</code></pre></td></tr>
<tr><td><code>mapNoData</code></td><td><code>bool</code></td><td>Should NO DATA values be mapped with the <code>expression</code>? Otherwise, they are mapped automatically to NO DATA.</td><td><pre><code>false</code></pre></td></tr>
</tbody></table>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>The following describes the types used in the parameters.</p>
<h3 id="expression"><a class="header" href="#expression">Expression</a></h3>
<p>Expressions are simple scripts to perform pixel-wise computations.
One can refer to the raster inputs as <code>A</code> for the first raster band, <code>B</code> for the second, and so on.
Furthermore, expressions can check with <code>A IS NODATA</code>, <code>B IS NODATA</code>, etc. for NO DATA values.
This is important if <code>mapNoData</code> is set to true.
Otherwise, NO DATA values are mapped automatically to the output NO DATA value.
Finally, the value <code>NODATA</code> can be used to output NO DATA.</p>
<p>Users can think of this implicit function signature for, e.g., two inputs:</p>
<pre><code class="language-Rust">fn (A: f64, B: f64) -&gt; f64
</code></pre>
<p>As a start, expressions contain algebraic operations and mathematical functions.</p>
<pre><code class="language-Rust">(A + B) / 2
</code></pre>
<p>In addition, branches can be used to check for conditions.</p>
<pre><code class="language-Rust">if A IS NODATA {
    B
} else {
    A
}
</code></pre>
<p>Function calls can be used to access utility functions.</p>
<pre><code class="language-Rust">max(A, 0)
</code></pre>
<p>Currently, the following functions are available:</p>
<ul>
<li><code>abs(a)</code>: absolute value</li>
<li><code>min(a, b)</code>, <code>min(a, b, c)</code>: minimum value</li>
<li><code>max(a, b)</code>, <code>max(a, b, c)</code>: maximum value</li>
<li><code>sqrt(a)</code>: square root</li>
<li><code>ln(a)</code>: natural logarithm</li>
<li><code>log10(a)</code>: base 10 logarithm</li>
<li><code>cos(a)</code>, <code>sin(a)</code>, <code>tan(a)</code>, <code>acos(a)</code>, <code>asin(a)</code>, <code>atan(a)</code>: trigonometric functions</li>
<li><code>pi()</code>, <code>e()</code>: mathematical constants</li>
<li><code>round(a)</code>, <code>ceil(a)</code>, <code>floor(a)</code>: rounding functions</li>
<li><code>mod(a, b)</code>: division remainder</li>
<li><code>to_degrees(a)</code>, <code>to_radians(a)</code>: conversion to degrees or radians</li>
</ul>
<p>To generate more complex expressions, it is possible to have variable assignments.</p>
<pre><code class="language-Rust">let mean = (A + B) / 2;
let coefficient = 0.357;
mean * coefficient
</code></pre>
<p>Note, that all assignments are separated by semicolons.
However, the last expression must be without a semicolon.</p>
<h2 id="inputs-1"><a class="header" href="#inputs-1">Inputs</a></h2>
<p>The <code>Expression</code> operator expects one rater input with at most 8 bands.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>SingleRasterSource</code></td></tr>
</tbody></table>
<h2 id="errors-2"><a class="header" href="#errors-2">Errors</a></h2>
<p>The parsing of the expression can fail if there are, e.g., syntax errors.</p>
<h2 id="example-json-14"><a class="header" href="#example-json-14">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Expression&quot;,
  &quot;params&quot;: {
    &quot;expression&quot;: &quot;(A - B) / (A + B)&quot;,
    &quot;outputType&quot;: &quot;F32&quot;,
    &quot;outputBand&quot;: {
      &quot;name&quot;: &quot;NDVI&quot;,
      &quot;measurement&quot;: {
        &quot;type&quot;: &quot;continuous&quot;,
        &quot;unit&quot;: &quot;NDVI&quot;
      }
    },
    &quot;mapNoData&quot;: false
  },
  &quot;sources&quot;: {
    &quot;raster&quot;: {
      &quot;type&quot;: &quot;RasterStacker&quot;,
      &quot;params&quot;: {},
      &quot;sources&quot;: {
        &quot;rasters&quot;: [
          {
            &quot;type&quot;: &quot;GdalSource&quot;,
            &quot;params&quot;: {
              &quot;data&quot;: &quot;sentinel2-b8&quot;
            }
          },
          {
            &quot;type&quot;: &quot;GdalSource&quot;,
            &quot;params&quot;: {
              &quot;data&quot;: &quot;sentinel2-b4&quot;
            }
          }
        ]
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gdalsource"><a class="header" href="#gdalsource">GdalSource</a></h1>
<p>The <code>GdalSource</code> is a <em>source operator</em> that reads raster data using GDAL.
The counterpart for vector data is the <a href="operators/./ogrsource.html"><code>OgrSource</code></a>.</p>
<h2 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th><th>Default Value</th></tr></thead><tbody>
<tr><td><code>data</code></td><td><code>DataId</code></td><td>The id of the data to be loaded</td><td><pre><code>&quot;ndvi&quot;</code></pre></td><td></td></tr>
</tbody></table>
<h2 id="inputs-2"><a class="header" href="#inputs-2">Inputs</a></h2>
<p>None</p>
<h2 id="errors-3"><a class="header" href="#errors-3">Errors</a></h2>
<p>If the given dataset does not exist or is not readable, an error is thrown.</p>
<h2 id="example-json-15"><a class="header" href="#example-json-15">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;GdalSource&quot;,
  &quot;params&quot;: {
    &quot;data&quot;: &quot;ndvi&quot;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpolation"><a class="header" href="#interpolation">Interpolation</a></h1>
<p>The <code>Interpolation</code> operator artificially increases the resolution of a raster by interpolating the values of the input raster.
If the operator is queried with a resolution that is coarser than the input resolution, the interpolation is not applied but the input raster is returned unchanged.
Unless a particular input resolution is specified, the resolution of the input raster is used, if it is known.</p>
<h2 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>interpolation</code></td><td><code>InterpolationMethod</code></td><td>the interpolation method to be used</td><td>&quot;nearestNeighbor&quot;</td></tr>
<tr><td><code>inputResolution</code></td><td><code>InputResolution</code></td><td>the query resolution for the source operator</td><td>&quot;source&quot;</td></tr>
</tbody></table>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<p>The following describes the types used in the parameters.</p>
<h3 id="interpolationmethod"><a class="header" href="#interpolationmethod">InterpolationMethod</a></h3>
<p>The operator supports the following interpolation methods:</p>
<table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>nearestNeighbor</code></td><td>The value of the nearest neighbor is used.</td></tr>
<tr><td><code>biLinear</code></td><td>The value is computed by bilinear interpolation.</td></tr>
</tbody></table>
<h3 id="inputresolution"><a class="header" href="#inputresolution">InputResolution</a></h3>
<p>The operator supports the following input resolutions:</p>
<table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>{&quot;type&quot;: &quot;source&quot;}</code></td><td>The resolution of the input raster is used.</td></tr>
<tr><td><code>{&quot;type&quot;: &quot;value&quot;, &quot;x&quot;: 0.1, &quot;y&quot;: 0.1}</code></td><td>The resolution is specified explicitly.</td></tr>
</tbody></table>
<h2 id="inputs-3"><a class="header" href="#inputs-3">Inputs</a></h2>
<p>The <code>Interpolation</code> operator expects exactly one <em>raster</em> input.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>SingleRasterSource</code></td></tr>
</tbody></table>
<h2 id="errors-4"><a class="header" href="#errors-4">Errors</a></h2>
<p>If the input resolution is set as &quot;source&quot; but the resolution of the input raster is not known, an error will be thrown.</p>
<h2 id="example-json-16"><a class="header" href="#example-json-16">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Raster&quot;,
  &quot;operator&quot;: {
    &quot;type&quot;: &quot;Interpolation&quot;,
    &quot;params&quot;: {
      &quot;interpolation&quot;: &quot;biLinear&quot;,
      &quot;inputResolution&quot;: {
        &quot;type&quot;: &quot;source&quot;
      }
    },
    &quot;sources&quot;: {
      &quot;raster&quot;: {
        &quot;type&quot;: &quot;GdalSource&quot;,
        &quot;params&quot;: {
          &quot;data&quot;: &quot;ndvi&quot;
        }
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linesimplification"><a class="header" href="#linesimplification">LineSimplification</a></h1>
<p>The <code>LineSimplification</code> operator allows simplifying <code>FeatureCollection</code>s of (multi-)lines or (multi-)polygons by removing vertices.
Users can select a simplification algorithm and specify an <code>epsilon</code> for parametrization.
Alternatively, they can omit the <code>epsilon</code>, which results in the <code>epsilon</code> being automatically determined by the query's spatial resolution.</p>
<p>For instance, you can remove the vertices of a large country polygon for drawing it on a small map.
This results in a simpler polygon that is easier to draw and reduces the amount of data that needs to be transferred.</p>
<h2 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>epsilon</code></td><td>(optional) number</td><td>Specify the parametrization of the simplification algorith, e.g. the distance threshold for two nodes in <em>Douglas-Peucker</em>. Must be &gt; 0.</td><td><pre>1.0</pre></td></tr>
<tr><td><code>algorithm</code></td><td><code>douglasPeucker</code> or <code>visvalingam</code></td><td>Select a simplification algorith for being used, e.g. <a href="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Douglas-Peucker</a> or <a href="https://en.wikipedia.org/wiki/Visvalingam%E2%80%93Whyatt_algorithm">Visvalingam</a></td><td><pre>&quot;douglasPeucker&quot;</pre></td></tr>
</tbody></table>
<h2 id="inputs-4"><a class="header" href="#inputs-4">Inputs</a></h2>
<p>The <code>LineSimplification</code> operator expects exactly one <em>vector</em> input.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>vector</code></td><td><code>SingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-5"><a class="header" href="#errors-5">Errors</a></h2>
<ul>
<li>If <code>epsilon</code> is set but &lt;= 0, an error is thrown.</li>
<li>If the input is not <code>MultiPolygon</code> or <code>MultiLineString</code>, an error is thrown.</li>
</ul>
<h2 id="example-json-17"><a class="header" href="#example-json-17">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;LineSimplification&quot;,
  &quot;params&quot;: {
    &quot;algorithm&quot;: &quot;douglasPeucker&quot;,
    &quot;epsilon&quot;: 1.0
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ne_10m_admin_0_countries&quot;
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;LineSimplification&quot;,
  &quot;params&quot;: {
    &quot;algorithm&quot;: &quot;visvalingam&quot;
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ne_10m_admin_0_countries&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neighborhood-aggregate"><a class="header" href="#neighborhood-aggregate">Neighborhood Aggregate</a></h1>
<p>The <code>NeighborhoodAggregate</code> operator computes an aggregate function for a pixel and its neighborhood.
The operator can be defined as a neighborhood matrix with either weights or predefined shapes and an aggregate function.</p>
<p>An example usage scenario is to calculate a Gaussian filter to smoothen or blur an image.
For each time step in the raster time series, the operator computes the aggregate for each pixel and its neighborhood.</p>
<p>The output data type is the same as the input data type.
As the matrix and the aggregate in- and outputs are defined as floating point values, the internal computation is done as floating point calculations.</p>
<h2 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>neighborhood</code></td><td><code>Neighborhood</code></td><td>Pixel neighborhood specification</td><td><pre><code>{<br>  &quot;type&quot;: &quot;weightsMatrix&quot;,<br>  &quot;weights&quot;: [<br>    [1.0, 2.0, 3.0],<br>    [4.0, 5.0, 6.0],<br>    [7.0, 8.0, 9.0]<br>  ]<br>}</code></pre></td></tr>
<tr><td><code>aggregateFunction</code></td><td><code>AggregateFunction</code></td><td>An aggregate function for a set of values</td><td><pre><code>&quot;sum&quot;</code></pre></td></tr>
</tbody></table>
<h2 id="types-2"><a class="header" href="#types-2">Types</a></h2>
<p>The following describes the types used in the parameters.</p>
<h3 id="neighborhood"><a class="header" href="#neighborhood">Neighborhood</a></h3>
<p>There are several types of neighborhoods.
They define a matrix of weights.
The rows and columns of this matrix must be odd.</p>
<h4 id="weightsmatrix"><a class="header" href="#weightsmatrix">WeightsMatrix</a></h4>
<p>The weights matrix is defined as an \( n \times m \) matrix of floating point values.
It is applied to the pixel and its neighborhood to serve as the input for the <em>aggregate function</em>.</p>
<p>For instance, a vertical derivative filter (a component of a Sobel filter) can be defined like this:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;weightsMatrix&quot;,
  &quot;weights&quot;: [
    [1.0, 0.0, -1.0],
    [2.0, 0.0, -2.0],
    [1.0, 0.0, -1.0]
  ]
}
</code></pre>
<p>The aggregate function should be <code>sum</code> in this case.</p>
<h4 id="rectangle"><a class="header" href="#rectangle">Rectangle</a></h4>
<p>The rectangle neighborhood is defined by its shape \( n \times m \).
The result is a <em>weights matrix</em> with all weights set to <code>1.0</code>.</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;rectangle&quot;,
  &quot;dimensions&quot;: [3, 3]
}
</code></pre>
<h3 id="aggregatefunction"><a class="header" href="#aggregatefunction">AggregateFunction</a></h3>
<p>The aggregate function computes a single value from a set of values.
The following aggregate functions are supported:</p>
<ul>
<li><code>sum</code>: The sum of all values</li>
<li><code>standardDeviation</code>: The standard deviation of all values.
This ignores <code>NO DATA</code> values.</li>
</ul>
<h2 id="inputs-5"><a class="header" href="#inputs-5">Inputs</a></h2>
<p>The <code>NeighborhoodAggregate</code> operator expects exactly one <em>raster</em> input.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>SingleRasterSource</code></td></tr>
</tbody></table>
<h2 id="errors-6"><a class="header" href="#errors-6">Errors</a></h2>
<p>If the neighborhood rows or columns are not positive or odd, an error will be thrown.</p>
<h2 id="example-json-18"><a class="header" href="#example-json-18">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;NeighborhoodAggregate&quot;,
  &quot;params&quot;: {
    &quot;neighborhood&quot;: {
      &quot;type&quot;: &quot;weightsMatrix&quot;,
      &quot;weights&quot;: [
        [1.0, 2.0, 3.0],
        [4.0, 5.0, 6.0],
        [7.0, 8.0, 9.0]
      ]
    },
    &quot;aggregateFunction&quot;: &quot;sum&quot;
  },
  &quot;sources&quot;: {
    &quot;raster&quot;: {
      &quot;type&quot;: &quot;GdalSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ogrsource"><a class="header" href="#ogrsource">OgrSource</a></h1>
<p>The <code>OgrSource</code> is a <em>source operator</em> that reads vector data using OGR.
The counterpart for raster data is the <a href="operators/./gdalsource.html"><code>GdalSource</code></a>.</p>
<h2 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th><th>Default Value</th></tr></thead><tbody>
<tr><td><code>data</code></td><td><code>DataId</code></td><td>The id of the data to be loaded</td><td><pre><code>&quot;places&quot;</code></pre></td><td></td></tr>
<tr><td><code>attributeProjection</code></td><td><code>Array&lt;String&gt;</code></td><td>(Optional) The list of attributes to load. If nothing is specified, all attributes will be loaded.</td><td><code>[&quot;name&quot;, &quot;population&quot;]</code></td><td></td></tr>
<tr><td><code>attributeFilters</code></td><td><code>Array&lt;AttributeFilter&gt;</code></td><td>(Optional) The list of filters to apply on the attributes of features. Only the features that match all of the filters will be loaded.</td><td><pre><code>[{&quot;attribute&quot;: &quot;population&quot;,<br> &quot;ranges&quot;: [[1000, 10000]]<br>}]</code></pre></td><td></td></tr>
</tbody></table>
<h2 id="types-3"><a class="header" href="#types-3">Types</a></h2>
<p>The following describes the types used in the parameters.</p>
<h3 id="attributefilter"><a class="header" href="#attributefilter">AttributeFilter</a></h3>
<p>The <code>AttributeFilter</code> defines one or more ranges on the values of an attribute. The ranges include the lower and upper bounds of the range.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Description</th><th></th></tr></thead><tbody>
<tr><td><code>attribute</code></td><td><code>String</code></td><td>The name of the attribute to filter.</td><td></td></tr>
<tr><td><code>ranges</code></td><td><code>Array&lt;Array&lt;String \| Number&gt;&gt;</code></td><td>The list of ranges to filter.</td><td></td></tr>
<tr><td><code>keepNulls</code></td><td><code>bool</code></td><td>(Optional) Specifies whether to keep null/no data entries, defaults to <code>false</code>.</td><td></td></tr>
</tbody></table>
<h2 id="inputs-6"><a class="header" href="#inputs-6">Inputs</a></h2>
<p>None</p>
<h2 id="errors-7"><a class="header" href="#errors-7">Errors</a></h2>
<p>If the given dataset does not exist or is not readable, an error is thrown.</p>
<h2 id="example-json-19"><a class="header" href="#example-json-19">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;OgrSource&quot;,
  &quot;params&quot;: {
    &quot;data&quot;: &quot;places&quot;,
    &quot;attributeProjection&quot;: [&quot;name&quot;, &quot;population&quot;],
    &quot;attributeFilters&quot;: [
      {
        &quot;attribute&quot;: &quot;population&quot;,
        &quot;ranges&quot;: [[1000, 10000]],
        &quot;keepNulls&quot;: false
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointinpolygon"><a class="header" href="#pointinpolygon">PointInPolygon</a></h1>
<p>The <code>PointInPolygon</code> operator filters point features of a (multi-)point collection with polygons.
In more detail, the points of each feature are checked against the polygons of the other collection.
If one or more point is included in any polygon's ring, the feature is included in the output.</p>
<p>For instance, you can filter tree features inside the polygons of a forest.
All features, that weren't inside any forest polygon, are considered either part of another forest or outliers and are thus removed.</p>
<h2 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h2>
<p>The operator is parameterless.</p>
<h2 id="inputs-7"><a class="header" href="#inputs-7">Inputs</a></h2>
<p>The <code>PointInPolygon</code> operator expects two <em>vector</em> inputs.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>points</code></td><td><code>SingleVectorSource</code></td></tr>
<tr><td><code>polygons</code></td><td><code>SingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-8"><a class="header" href="#errors-8">Errors</a></h2>
<p>If the <code>points</code> vector input is not a (multi-)point feature collection, an error is thrown.</p>
<p>If the <code>polygons</code> vector input is not a (multi-)polygon feature collection, an error is thrown.</p>
<h2 id="example-json-20"><a class="header" href="#example-json-20">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;PointInPolygon&quot;,
  &quot;params&quot;: {},
  &quot;sources&quot;: {
    &quot;points&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;places&quot;,
        &quot;attributeProjection&quot;: [&quot;name&quot;, &quot;population&quot;]
      }
    },
    &quot;polygons&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;germany_outline&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rasterization"><a class="header" href="#rasterization">Rasterization</a></h1>
<p>The <code>Rasterization</code> operator creates a raster from a point vector source.
It offers two options for rasterization: A grid rasterization and a (gaussian) density rasterization (heatmap).</p>
<h2 id="inputs-8"><a class="header" href="#inputs-8">Inputs</a></h2>
<p>The <code>Rasterization</code> operator expects exactly one <em>vector</em> input.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>SingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>params</code></td><td><code>GridOrDensity</code></td><td>The type and parameters for the rasterization to perform.</td><td><code>{&quot;type&quot;: &quot;grid&quot;, ...}</code></td></tr>
</tbody></table>
<p><code>GridOrDensity</code> contains a field <code>type</code> which can have the value <code>grid</code> or <code>density</code> for a grid rasterization or density rasterization, respectively.</p>
<p><code>GridOrDensity</code> has additional fields which are parameters specific to the type of the rasterization. These are described below separately.</p>
<h3 id="grid-rasterization"><a class="header" href="#grid-rasterization">Grid Rasterization</a></h3>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>spatialResolution</code></td><td><code>SpatialResolution</code></td><td>The spatial resolution of the grid/size of the grid cells.</td><td><code>{&quot;x&quot;: 10.0, &quot;y&quot;: 10.0}</code></td></tr>
<tr><td><code>originCoordinate</code></td><td><code>Coordinate2D</code></td><td>The origin coordinate to which the grid is aligned.</td><td><code>{&quot;x&quot;: 0.0, &quot;y&quot;: 0.0}</code></td></tr>
<tr><td><code>gridSizeMode</code></td><td><code>fixed</code> or <code>relative</code></td><td>The mode how the grid resolution is interpreted.</td><td><code>&quot;fixed&quot;</code></td></tr>
</tbody></table>
<h4 id="types-4"><a class="header" href="#types-4">Types</a></h4>
<p>The following describes the types used in the grid rasterization parameters.</p>
<p>The parameters <code>spatialResolution</code> and <code>originCoordinate</code> consist of two fields <code>x</code> and <code>y</code> which describe a resolution/position in x/y direction.</p>
<p>For <code>gridSizeMode</code> the two options <code>fixed</code> and <code>relative</code> are available.
<code>Fixed</code> means the <code>spatialResolution</code> is interpreted as a constant grid cell size. 
<code>Relative</code> means the <code>spatialResolution</code> is used as a multiplier for a query's spatial resolution, making the resulting grid size adaptive to the query resolution.</p>
<h3 id="density-rasterization"><a class="header" href="#density-rasterization">Density Rasterization</a></h3>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>cutoff</code></td><td><code>number</code></td><td>Defines the cutoff (as percentage of maximum density) down to which a point is taken into account for an output pixel density value</td><td><code>0.01</code></td></tr>
<tr><td><code>stddev</code></td><td><code>number</code></td><td>The standard deviation parameter for the gaussian function.</td><td><code>1.0</code></td></tr>
</tbody></table>
<p>The <code>cutoff</code> percentage (must be in [0, 1)) is treated as a hard cutoff point. A larger <code>cutoff</code> percentage leads to faster processing, however it also introduces inaccuracies in the result since points further than the derived radius away from a pixel do not influence its value.
It is meant to be set such that the ignored density values are small enough to not make a visible difference in the resulting raster.</p>
<h4 id="errors-9"><a class="header" href="#errors-9">Errors</a></h4>
<p>If the <code>cutoff</code> is not in [0, 1) or the <code>stddev</code> is negative, an error will be thrown.</p>
<h2 id="example-json-21"><a class="header" href="#example-json-21">Example JSON</a></h2>
<h3 id="grid-rasterization-1"><a class="header" href="#grid-rasterization-1">Grid Rasterization</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Raster&quot;,
  &quot;operator&quot;: {
    &quot;type&quot;: &quot;Rasterization&quot;,
    &quot;params&quot;: {
      &quot;type&quot;: &quot;grid&quot;,
      &quot;spatialResolution&quot;: {
        &quot;x&quot;: 10,
        &quot;y&quot;: 10
      },
      &quot;gridSizeMode&quot;: &quot;fixed&quot;,
      &quot;originCoordinate&quot;: {
        &quot;x&quot;: 0, 
        &quot;y&quot;: 0
      }
    },
    &quot;sources&quot;: {
      &quot;vector&quot;: {
        &quot;type&quot;: &quot;OgrSource&quot;,
        &quot;params&quot;: {
          &quot;data&quot;: &quot;ne_10m_ports&quot;,
          &quot;attributeProjection&quot;: null,
          &quot;attributeFilters&quot;: null
        }
      }
    }
  }
}
</code></pre>
<h3 id="density-rasterization-1"><a class="header" href="#density-rasterization-1">Density Rasterization</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Raster&quot;,
  &quot;operator&quot;: {
    &quot;type&quot;: &quot;Rasterization&quot;,
    &quot;params&quot;: {
      &quot;type&quot;: &quot;density&quot;,
      &quot;cutoff&quot;: 0.01,
      &quot;stddev&quot;: 1
    },
    &quot;sources&quot;: {
      &quot;vector&quot;: {
        &quot;type&quot;: &quot;OgrSource&quot;,
        &quot;params&quot;: {
          &quot;data&quot;: &quot;ne_10m_ports&quot;,
          &quot;attributeProjection&quot;: null,
          &quot;attributeFilters&quot;: null
        }
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rasterscaling"><a class="header" href="#rasterscaling">RasterScaling</a></h1>
<p>The raster scaling operator scales/unscales the values of a raster by a given slope factor and offset.
This allows to shrink and expand the value range of the pixel values needed to store a raster. It also allows to shift values to all-positive values and back.
We use the <a href="https://gdal.org/index.html">GDAL</a> terms of <a href="https://gdal.org/programs/gdal_translate.html#cmdoption-gdal_translate-scale">scale</a> and <a href="https://gdal.org/programs/gdal_translate.html#cmdoption-gdal_translate-unscale">unscale</a>.
Raster data is often scaled to reduce memory/storage consumption.
To get the &quot;real&quot; raster values the unscale operation is applied.
Keep in mind that scaling might reduce the precision of the pixel values.
(To actually reduce the size of the raster, use the <a href="operators/./rastertypeconversion.html">raster type conversion operator</a> and transform to a smaller datatype after scaling.)</p>
<p>The operator applies the following formulas to every pixel.</p>
<p>For <em>unscaling</em> the formula is: <code>p_new = p_old * slope + offset</code>. The key for this mode is <code>mulSlopeAddOffset</code>.</p>
<p>For <em>scaling</em> the formula is: <code>p_new = (p_old - offset) / slope</code>. The key for this mode is <code>subOffsetDivSlope</code>.</p>
<p><code>p_old</code> and <code>p_new</code> refer to the old and new pixel value. The slope and offset values are either properties attached to the input raster or a fixed value.</p>
<p>An example for Meteosat Second Generation properties is:</p>
<ul>
<li>offset: <code>msg.calibration_offset</code></li>
<li>slope: <code>msg.calibration_slope</code></li>
</ul>
<h2 id="parameters-9"><a class="header" href="#parameters-9">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>slope</code></td><td><code>SlopeOffsetSelection</code></td><td>the key or value to use for <code>slope</code></td><td><code>{&quot;type&quot;: &quot;metadataKey&quot; &quot;domain&quot;: &quot;&quot;, &quot;key&quot;: &quot;scale&quot; }</code></td></tr>
<tr><td><code>offset</code></td><td><code>SlopeOffsetSelection</code></td><td>the key or value to use for <code>offset</code></td><td><code>{&quot;type&quot;: &quot;constant&quot; &quot;value&quot;: 0.1 }</code></td></tr>
<tr><td><code>scalingMode</code></td><td><code>mulSlopeAddOffset</code> OR <code>subOffsetDivSlope</code></td><td>select scale or unscale mode</td><td><code>&quot;mulSlopeAddOffset&quot;</code></td></tr>
<tr><td><code>outputMeasurement</code>*</td><td>(optional) <a href="operators//datatypes/measurement.html"><code>Measurement</code></a></td><td>the measurement of the data produced by the operator</td><td><code>{&quot;type&quot;: &quot;continuous&quot;, &quot;measurement&quot;: &quot;Reflectance&quot;,&quot;unit&quot;: &quot;%&quot;}</code></td></tr>
</tbody></table>
<p>* if no <code>outputMeasurement</code> is given, the measurement of the input raster is used.</p>
<p>The <code>RasterScaling</code> operator expects exactly one <em>raster</em> input.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>SingleRasterSource</code></td></tr>
</tbody></table>
<h2 id="types-5"><a class="header" href="#types-5">Types</a></h2>
<p>The following describes the types used in the parameters.</p>
<h3 id="slopeoffsetselection"><a class="header" href="#slopeoffsetselection">SlopeOffsetSelection</a></h3>
<p>The <code>SlopeOffsetSelection</code> type is used to specify a metadata key or a constant value.</p>
<table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>{&quot;type&quot;: &quot;auto&quot;}</code> *</td><td>Use slope and offset from the tiles properties</td></tr>
<tr><td><code>{&quot;type&quot;: &quot;constant&quot;, &quot;value&quot;: number}</code></td><td>A constant value.</td></tr>
<tr><td><code>{&quot;type&quot;: &quot;metadataKey&quot;, &quot;domain&quot;: string, &quot;key&quot;: string}</code></td><td>A metadata key to lookup dynamic values from raster (tile) properties.</td></tr>
</tbody></table>
<p>* if set to <code>&quot;auto&quot;</code>, the operator will use the values from the decicated (GDAL) raster properties for scale and offset.</p>
<h2 id="example-json-22"><a class="header" href="#example-json-22">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;RasterScaling&quot;,
  &quot;params&quot;: {
    &quot;slope&quot;: {
      &quot;type&quot;: &quot;metadataKey&quot;,
      &quot;domain&quot;: &quot;&quot;,
      &quot;key&quot;: &quot;scale&quot;
    },
    &quot;offset&quot;: {
      &quot;type&quot;: &quot;constant&quot;,
      &quot;value&quot;: 1.0
    },
    &quot;outputMeasurement&quot;: null,
    &quot;scalingMode&quot;: &quot;mulSlopeAddOffset&quot;
  },
  &quot;sources&quot;: {
    &quot;raster&quot;: {
      &quot;type&quot;: &quot;GdalSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;modis-b6&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rasterstacker"><a class="header" href="#rasterstacker">RasterStacker</a></h1>
<p>The <code>RasterStacker</code> stacks all of its inputs into a single raster time-series.
It does so by querying all of its inputs and outputting them by band, space and then time.
The output raster will have as many bands as the sum of all input bands.
The tiles are automatically temporally aligned.</p>
<p>All inputs must have the same data type and spatial reference.</p>
<h2 id="parameters-10"><a class="header" href="#parameters-10">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td>renameBands</td><td><code>RenameBands</code></td><td>Specification of how to rename the bands to avoid conflicts</td><td><pre><code>{ &quot;type&quot;: &quot;default&quot; }</pre></td></tr>
</tbody></table>
<h2 id="types-6"><a class="header" href="#types-6">Types</a></h2>
<p>The following describes the types used in the parameters.</p>
<h3 id="renamebands"><a class="header" href="#renamebands">RenameBands</a></h3>
<p>The <code>RenameBands</code> type is used to specify how to rename the bands to avoid conflicts.</p>
<table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>{&quot;type&quot;: &quot;default&quot;}</code></td><td>Appends &quot; (n)&quot; to the band name with the smallest <code>n</code> that avoids a conflict</td></tr>
<tr><td><code>{&quot;type&quot;: &quot;suffix&quot;, &quot;values&quot;: [string]}</code></td><td>Specifies a suffix for each input, to be appended to the band names</td></tr>
<tr><td><code>{&quot;type&quot;: &quot;rename&quot;, &quot;values&quot;: [string]}</code></td><td>A list of names for each band of all inputs to be used instead of the original name</td></tr>
</tbody></table>
<h2 id="inputs-9"><a class="header" href="#inputs-9">Inputs</a></h2>
<p>The <code>RasterStacker</code> operator supports up to 8 raster inputs.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>rasters</code></td><td><code>MultipleRasterSources</code></td></tr>
</tbody></table>
<h2 id="example-json-23"><a class="header" href="#example-json-23">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;RasterStacker&quot;,
  &quot;params&quot;: {
    &quot;renameBands&quot;: {
      &quot;type&quot;: &quot;rename&quot;,
      &quot;values&quot;: [&quot;ndvi&quot;, &quot;ndvi_masked&quot;]
    }
  },
  &quot;sources&quot;: {
    &quot;rasters&quot;: [
      {
        &quot;type&quot;: &quot;GdalSource&quot;,
        &quot;params&quot;: {
          &quot;data&quot;: &quot;ndvi&quot;
        }
      },
      {
        &quot;type&quot;: &quot;Expression&quot;,
        &quot;params&quot;: {
          &quot;expression&quot;: &quot;if A &gt; 100 { A } else { 0 }&quot;,
          &quot;outputType&quot;: &quot;U8&quot;,
          &quot;mapNoData&quot;: false
        },
        &quot;sources&quot;: {
          &quot;a&quot;: {
            &quot;type&quot;: &quot;GdalSource&quot;,
            &quot;params&quot;: {
              &quot;data&quot;: &quot;ndvi&quot;
            }
          }
        }
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rastertypeconversion"><a class="header" href="#rastertypeconversion">RasterTypeConversion</a></h1>
<p>The <code>RasterTypeConversion</code> operator allows changing the data type of raster data.
It transforms all pixels into the new data type.</p>
<ol>
<li>
<p>Applying the operator could lead to a loss of precision, e.g., converting a <code>F32</code> value of <code>3.1</code> to a <code>U8</code> will return a value of <code>3</code>.</p>
</li>
<li>
<p>If the old value is not valid in the new type it will clip at the value range of the new type. E.g., converting a <code>F32</code> value of <code>300.0</code> to a <code>U8</code> will return a value of <code>255</code>.</p>
</li>
</ol>
<h2 id="parameters-11"><a class="header" href="#parameters-11">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>outputDataType</code></td><td>[<code>RasterDataType</code>]</td><td>the output type</td><td>&quot;U8&quot;</td></tr>
</tbody></table>
<p>The <code>RasterTypeConversion</code> operator expects exactly one <em>raster</em> input.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>SingleRasterSource</code></td></tr>
</tbody></table>
<h2 id="example-json-24"><a class="header" href="#example-json-24">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;RasterTypeConversion&quot;,
  &quot;params&quot;: {
    &quot;outputDataType&quot;: &quot;U8&quot;
  },
  &quot;sources&quot;: {
    &quot;raster&quot;: {
      &quot;type&quot;: &quot;GdalSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rastervectorjoin"><a class="header" href="#rastervectorjoin">RasterVectorJoin</a></h1>
<p>The <code>RasterVectorJoin</code> operator allows combining a single vector input and multiple raster inputs.
For each raster input, a new column is added to the collection from the vector input.
The new column contains the value of the raster at the location of the vector feature.
For features covering multiple pixels like <code>MultiPoints</code> or <code>MultiPolygons</code>, the value is calculated using an aggregation function selected by the user.
The same is true if the temporal extent of a vector feature covers multiple raster time steps.
More details are described below.</p>
<p><strong>Example</strong>:
You have a collection of agricultural fields (<code>Polygons</code>) and a collection of raster images containing each pixel's monthly NDVI value.
For your application, you want to know the NDVI value of each field.
The <code>RasterVectorJoin</code> operator allows you to combine the vector and raster data and offers multiple spatial and temporal aggregation strategies.
For example, you can use the <code>first</code> aggregation function to get the NDVI value of the first pixel that intersects with each field.
This is useful for exploratory analysis since the computation is very fast.
To calculate the mean NDVI value of all pixels that intersect with the field you should use the <code>mean</code> aggregation function.
Since the NDVI data is a monthly time series, you have to specify the temporal aggregation function as well.
The default is <code>none</code> which will create a new feature for each month.
Other options are <code>first</code> and <code>mean</code> which will calculate the first or mean NDVI value for each field over time.</p>
<h2 id="inputs-10"><a class="header" href="#inputs-10">Inputs</a></h2>
<p>The <code>RasterVectorJoin</code> operator expects one <em>vector</em> input and one or more <em>raster</em> inputs.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>sources</code></td><td><code>SingleVectorMultipleRasterSources</code></td></tr>
</tbody></table>
<h2 id="parameters-12"><a class="header" href="#parameters-12">Parameters</a></h2>
<p>The <code>RasterVectorJoin</code> operator has the following parameters:</p>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>names</code></td><td><code>Array&lt;String&gt;</code></td><td>Each name reflects the output column of the join result.</td><td><pre>&quot;[&quot;NDVI&quot;, &quot;Elevation&quot;]&quot;</pre></td></tr>
<tr><td><code>featureAggregation</code></td><td><code>first</code> or <code>mean</code></td><td>The aggregation function to use for features covering multiple pixels.</td><td><pre>&quot;first&quot;</pre></td></tr>
<tr><td><code>featureAggregationIgnoreNoData</code></td><td>(optional) <code>boolean</code></td><td>Whether to ignore no data values in the aggregation. Defaults to <code>false</code></td><td><pre>false</pre></td></tr>
<tr><td><code>temporalAggregation</code></td><td><code>none</code>, <code>first</code> or <code>mean</code></td><td>The aggregation function to use for features covering multiple (raster) time steps.</td><td><pre>&quot;none&quot;</pre></td></tr>
<tr><td><code>temporalAggregationIgnoreNoData</code></td><td>(optional) <code>boolean</code></td><td>Whether to ignore no data values in the aggregation. Defaults to <code>false</code></td><td><pre>false</pre></td></tr>
</tbody></table>
<h2 id="errors-10"><a class="header" href="#errors-10">Errors</a></h2>
<p>If the length of <code>names</code> is not equal to the number of raster inputs, an error is thrown.</p>
<h2 id="example-json-25"><a class="header" href="#example-json-25">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;RasterVectorJoin&quot;,
  &quot;params&quot;: {
    &quot;names&quot;: [&quot;NDVI&quot;],
    &quot;featureAggregation&quot;: &quot;first&quot;,
    &quot;temporalAggregation&quot;: &quot;mean&quot;,
    &quot;temporalAggregationIgnoreNoData&quot;: true
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;places&quot;
      }
    },
    &quot;rasters&quot;: [
      {
        &quot;type&quot;: &quot;GdalSource&quot;,
        &quot;params&quot;: {
          &quot;data&quot;: &quot;ndvi&quot;
        }
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reprojection"><a class="header" href="#reprojection">Reprojection</a></h1>
<p>The <code>Reprojection</code> operator reprojects data from one spatial reference system to another.
It accepts exactly one input which can either be a raster or a vector data stream.
The operator produces all data that, after reprojection, is contained in the query rectangle.</p>
<h2 id="data-type-specifics"><a class="header" href="#data-type-specifics">Data type specifics</a></h2>
<p>The concrete behavior depends on the data type.</p>
<h3 id="vector-data"><a class="header" href="#vector-data">Vector data</a></h3>
<p>The reprojection operator reprojects all coordinates of the features individually.
The result contains all features that, after reprojection, are <em>intersected</em> by the query rectangle.
If not all coordinates of the vector data stream could be projected, the operator returns an error.</p>
<h3 id="raster-data"><a class="header" href="#raster-data">Raster data</a></h3>
<p>To create tiles in the target projection, the operator first loads the corresponding tiles in the source projection.
Note, that in order to create one reprojected output tile, it may be necessary to load multiple source tiles.
For each output pixel, the operator takes the value of the input pixel nearest to its upper left corner.</p>
<p>In order to obtain precise results but avoid loading too much data, the operators estimate the resolution in which it loads the input raster stream.
The estimate is based on the target resolution defined by the query rectangle and the relationship between the length of the diagonal of the query rectangle in both projections.
Please refer to the source code for details.</p>
<p>In case a tile, or part of a tile, is not available in the source projection because it is outside of the defined extent, the operator will produce pixels with <em>no data</em> values.
If the input raster stream has no <em>no data</em> value defined, the value <em>0</em> will be used instead.</p>
<h2 id="parameters-13"><a class="header" href="#parameters-13">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>targetSpatialReference</code></td><td><code>String</code></td><td>The srs string (<em>authority:code</em>) of the target spatial reference.</td><td><code>EPSG:4326</code></td></tr>
</tbody></table>
<h2 id="inputs-11"><a class="header" href="#inputs-11">Inputs</a></h2>
<p>The <code>Reprojection</code> operator expects exactly one <em>raster</em> or <em>vector</em> input.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>RasterOrVectorOperator</code></td></tr>
</tbody></table>
<h2 id="errors-11"><a class="header" href="#errors-11">Errors</a></h2>
<p>The operator returns an error if the target projection is unknown or if the input data cannot be reprojected.</p>
<h2 id="example-json-26"><a class="header" href="#example-json-26">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Reprojection&quot;,
  &quot;params&quot;: {
    &quot;targetSpatialReference&quot;: &quot;EPSG:4326&quot;
  },
  &quot;sources&quot;: {
    &quot;source&quot;: {
      &quot;type&quot;: &quot;GdalSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rgb-composite"><a class="header" href="#rgb-composite">RGB Composite</a></h1>
<p>The <code>RGB</code> composite operator computes pixel-wise rgba values on three raster sources, referred to as red, green, and blue.
They fill the red, green, and blue parts of the output, which are <code>U32</code> pixels, respectively.
Internally, the four bytes of the (unitless) <code>U32</code> are filled with red, green, blue and alpha information.
The special <a href="operators/../datatypes/colorizer.html#rgba"><code>rgba</code></a> colorizer symbology treats the values &quot;as is&quot; and maps them to the RGB output.</p>
<h2 id="parameters-14"><a class="header" href="#parameters-14">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>redMin</code></td><td><code>number</code></td><td>Minimum value for red source</td><td><pre>0</pre></td></tr>
<tr><td><code>redMax</code></td><td><code>number</code></td><td>Minimum value for red source</td><td><pre>255</pre></td></tr>
<tr><td><code>redScale</code></td><td><code>number</code> (optional)</td><td>Scaling factor for the red source in <code>[0, 1]</code></td><td><pre>1</pre></td></tr>
<tr><td><code>greenMax</code></td><td><code>number</code></td><td>Minimum value for green source</td><td><pre>255</pre></td></tr>
<tr><td><code>greenMin</code></td><td><code>number</code></td><td>Minimum value for green source</td><td><pre>0</pre></td></tr>
<tr><td><code>greenScale</code></td><td><code>number</code> (optional)</td><td>Scaling factor for the green source in <code>[0, 1]</code></td><td><pre>0.5</pre></td></tr>
<tr><td><code>blueMin</code></td><td><code>number</code></td><td>Minimum value for blue source</td><td><pre>0</pre></td></tr>
<tr><td><code>blueMax</code></td><td><code>number</code></td><td>Minimum value for blue source</td><td><pre>255</pre></td></tr>
<tr><td><code>blueScale</code></td><td><code>number</code> (optional)</td><td>Scaling factor for the blue source in <code>[0, 1]</code></td><td><pre>0.75</pre></td></tr>
</tbody></table>
<h2 id="inputs-12"><a class="header" href="#inputs-12">Inputs</a></h2>
<p>The <code>RGB</code> composite operator expects three <em>raster</em> inputs.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>red</code></td><td><code>SingleRasterSource</code></td></tr>
<tr><td><code>green</code></td><td><code>SingleRasterSource</code></td></tr>
<tr><td><code>blue</code></td><td><code>SingleRasterSource</code></td></tr>
</tbody></table>
<h2 id="errors-12"><a class="header" href="#errors-12">Errors</a></h2>
<p>The parsing of the parameters can fail if, e.g., scale values are not in the range <code>[0, 1]</code>.</p>
<h2 id="example-json-27"><a class="header" href="#example-json-27">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Rgb&quot;,
  &quot;params&quot;: {
    &quot;redMin&quot;: 0,
    &quot;redMax&quot;: 2000,
    &quot;redScale&quot;: 1,
    &quot;greenMin&quot;: 0,
    &quot;greenMax&quot;: 2000,
    &quot;greenScale&quot;: 1,
    &quot;blueMin&quot;: 0,
    &quot;blueMax&quot;: 2000,
    &quot;blueScale&quot;: 1
  },
  &quot;sources&quot;: {
    &quot;red&quot;: {
      &quot;type&quot;: &quot;GdalSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;sentinel2-b2&quot;
      }
    },
    &quot;green&quot;: {
      &quot;type&quot;: &quot;GdalSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;sentinel2-b3&quot;
      }
    },
    &quot;blue&quot;: {
      &quot;type&quot;: &quot;GdalSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;sentinel2-b4&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="temporalrasteraggregation"><a class="header" href="#temporalrasteraggregation">TemporalRasterAggregation</a></h1>
<p>The <code>TemporalRasterAggregation</code> aggregates a raster time series into uniform time intervals (windows).
The output is a time series that begins with the first window that contains the <code>start</code> of the query time.
Each time slice has the same length, defined by the <code>window</code> parameter.
The pixel values are computed by aggregating all rasters that are contained in the input and that are valid in the current window using the defined <code>aggregation</code> method.
All output slices that are contained in the query time interval are produced by the operator.
The optional <code>windowReference</code> parameter allows specifying a custom anchor point for the windows.
This is the imagined start from which on the timeline is divided into uniform aggregation windows.
By default, it is <code>1970-01-01T00:00:00Z</code> which means that windows of, e.g., 1 hour or 1 month will begin at the full hour or the start of the month.</p>
<p>An example usage scenario is to transform a daily raster time series into monthly aggregates.
Here, the query should start at the beginning of the month and the <code>window</code> should be 1 month.
The aggregation method allows calculating, e.g., the maximum or mean value for each pixel.
If we perform a query with time [2021-01-01, 2021-04-01), we would get a time series with three time steps.
If we perform a query with an instant like [2021-01-01, 2021-01-01), we will get a single time step containing the aggregated values for January 2021.</p>
<h2 id="parameters-15"><a class="header" href="#parameters-15">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>aggregation</code></td><td><a href="operators/temporalrasteraggregation.html#aggregation"><code>Aggregation</code></a></td><td>method for aggregating pixels</td><td><pre><code>{<br>  &quot;type&quot;: &quot;max&quot;,<br>  &quot;ignoreNoData&quot;: false<br>}</code></pre></td></tr>
<tr><td><code>window</code></td><td><a href="operators//datatypes/timestep.html"><code>TimeStep</code></a></td><td>length of time steps</td><td><pre><code>{<br>  &quot;granularity&quot;: &quot;Months&quot;,<br>  &quot;step&quot;: 1<br>}</code></pre></td></tr>
<tr><td><code>windowReference</code></td><td><a href="operators//datatypes/timeinstance.html"><code>TimeInstance</code></a></td><td>(Optional) anchor point for the aggregation windows. Default value is <code>1970-01-01T00:00:00Z</code></td><td><code>1970-01-01T00:00:00Z</code></td></tr>
<tr><td><code>outputType</code></td><td><a href="operators//datatypes/rasterdatatype.html"><code>RasterDataType</code></a></td><td>(Optional) A raster data type for the output. Same as input, if not specified.</td><td><pre><code>U8</code><pre></td></tr>
</tbody></table>
<h2 id="types-7"><a class="header" href="#types-7">Types</a></h2>
<p>The following describes the types used in the parameters.</p>
<h3 id="aggregation"><a class="header" href="#aggregation">Aggregation</a></h3>
<p>There are different methods that can be used to aggregate the raster time series.
Encountering a <em>no data</em> value makes the aggregation value of a pixel also <em>no data</em> unless the <code>ignoreNoData</code> parameter is set to <code>true</code>.</p>
<table><thead><tr><th>Variant</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><code>min</code></td><td><code>ignoreNoData</code>: <code>bool</code></td><td>minimum value</td></tr>
<tr><td><code>max</code></td><td><code>ignoreNoData</code>: <code>bool</code></td><td>maximum value</td></tr>
<tr><td><code>first</code></td><td><code>ignoreNoData</code>: <code>bool</code></td><td>first encountered value</td></tr>
<tr><td><code>last</code></td><td><code>ignoreNoData</code>: <code>bool</code></td><td>last encountered value</td></tr>
<tr><td><code>mean</code></td><td><code>ignoreNoData</code>: <code>bool</code></td><td>mean value</td></tr>
<tr><td><code>sum</code></td><td><code>ignoreNoData</code>: <code>bool</code></td><td>sum of the values</td></tr>
<tr><td><code>count</code></td><td><code>ignoreNoData</code>: <code>bool</code></td><td>count the number of values</td></tr>
</tbody></table>
<p><strong>Attention:</strong> For the variants <code>sum</code> and <code>count</code>, a saturating addition is used.
This means, that if the sum of two values exceeds the maximum value of the data type, the result will be the maximum value of the data type.
Thus, users must be aware to choose a data type that is large enough to hold the result of the aggregation.</p>
<h2 id="inputs-13"><a class="header" href="#inputs-13">Inputs</a></h2>
<p>The <code>TemporalRasterAggregation</code> operator expects exactly one <em>raster</em> input.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>raster</code></td><td><code>SingleRasterSource</code></td></tr>
</tbody></table>
<h2 id="errors-13"><a class="header" href="#errors-13">Errors</a></h2>
<p>If the aggregation method is <code>first</code>, <code>last</code>, or <code>mean</code> and the input raster has no <em>no data</em> value, an error is thrown.</p>
<h2 id="example-json-28"><a class="header" href="#example-json-28">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;TemporalRasterAggregation&quot;,
  &quot;params&quot;: {
    &quot;aggregation&quot;: {
      &quot;type&quot;: &quot;max&quot;,
      &quot;ignoreNoData&quot;: false
    },
    &quot;window&quot;: {
      &quot;granularity&quot;: &quot;Months&quot;,
      &quot;step&quot;: 1
    },
    &quot;windowReference&quot;: &quot;1970-01-01T00:00:00Z&quot;,
    &quot;sources&quot;: {
      &quot;raster&quot;: {
        &quot;type&quot;: &quot;GdalSource&quot;,
        &quot;params&quot;: {
          &quot;data&quot;: &quot;ndvi&quot;
        }
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timeprojection"><a class="header" href="#timeprojection">TimeProjection</a></h1>
<p>The <code>TimeProjection</code> projects vector dataset timestamps to new granularities and ranges.
The output is a new vector dataset with the same geometry and attributes as the input.
However, each time step is projected to a new time range.
Moreover, the <a href="operators/./../datatypes/queryrectangle.html"><code>QueryRectangle</code>'s</a> temporal extent is enlarged as well to include the projected time range.</p>
<p>An example usage scenario is to transform snapshot observations into yearly time slices.
For instance, animal occurrences are observed at a daily granularity.
If you want to aggregate the data to a yearly granularity, you can use the <code>TimeProjection</code> operator.
This will change the validity of each element in the dataset to the full year where it was observed.
This is, for instance, useful when you want to combine it with raster time series and use different temporal semantics than the originally recorded validities.</p>
<h2 id="parameters-16"><a class="header" href="#parameters-16">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>step</code></td><td><a href="operators//datatypes/timestep.html"><code>TimeStep</code></a></td><td>time granularity and size for the projection</td><td><pre><code>{<br>  &quot;granularity&quot;: &quot;years&quot;,<br>  &quot;step&quot;: 1<br>}</code></pre></td></tr>
<tr><td><code>stepReference</code></td><td><a href="operators//datatypes/timeinstance.html"><code>TimeInstance</code></a></td><td>(Optional) an anchor point for the time <code>step</code></td><td><pre>&quot;2010-01-01T00:00:00Z&quot;</pre></td></tr>
</tbody></table>
<h2 id="inputs-14"><a class="header" href="#inputs-14">Inputs</a></h2>
<p>The <code>TimeProjection</code> operator expects exactly one <em>vector</em> input.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>vector</code></td><td><code>SingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-14"><a class="header" href="#errors-14">Errors</a></h2>
<p>If the <code>step</code> is negative, an error is thrown.</p>
<h2 id="example-json-29"><a class="header" href="#example-json-29">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;TimeProjection&quot;,
  &quot;params&quot;: {
    &quot;step&quot;: {
      &quot;granularity&quot;: &quot;years&quot;,
      &quot;step&quot;: 1
    }
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timeshift"><a class="header" href="#timeshift">TimeShift</a></h1>
<p>The <code>TimeShift</code> operator allows retrieving data temporally relative to the actual <a href="operators/./../datatypes/queryrectangle.html"><code>QueryRectangle</code></a>.
It shifts the query rectangle by a given amount of time and modifies the result data accordingly.
Users have two options for specifying the time shift:</p>
<ol>
<li>Relative shift – shift relatively to the query rectangle, e.g., one month or one year to the past.
This can be useful for comparing multiple points in time relative to the query rectangle.</li>
<li>Absolute shift – change query rectangle to a fixed temporal reference, e.g., January 2014.
This can be used to compare data in the query rectangle's time to a fixed point of reference.</li>
</ol>
<p>The output is either a stream of raster data or a stream of vector data depending on the input.</p>
<p>An example usage scenario is to compare the current time with the previous time of the same raster data.
For instance, a raster source outputs monthly data aggregates of mean temperatures.
If you want to compute the difference between the current month and the previous month, you can use the <code>TimeShift</code> operator.
You will have two workflows.
One is the unmodified temperature raster source.
The other is the same source, shifted by one month.
Then, you can use both workflows as sources of an <a href="operators/./expression.html"><code>Expression</code></a> operator.</p>
<p><em>Note</em>: This operator modifies the time values of the returned data.
For rasters and vector data, it shifts the time intervals opposite to the time shift specified in the operator.
This is necessary to have only data inside the result that is part of the <a href="operators/./../datatypes/queryrectangle.html"><code>QueryRectangle</code>'s</a> time interval.
As an example, we shift monthly data by one month to the past.
Our query rectangle points to February.
Then, the operator shifts the query rectangle to January.
The data, originally valid for January, is shifted forward to February again, to fit into the original query rectangle, which is February.
<img src="operators/../images/time-shift-explanation.png" alt="Time Shift" /></p>
<h2 id="parameters-17"><a class="header" href="#parameters-17">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>relative</code> or <code>absolute</code></td><td>shift relatively or absolute</td><td><pre>&quot;relative&quot;</pre></td></tr>
</tbody></table>
<h3 id="relative"><a class="header" href="#relative">Relative</a></h3>
<p>If <code>type</code> is <code>relative</code>, you need to specify the following parameters:</p>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>granularity</code></td><td><a href="operators//datatypes/timestep.html"><code>TimeGranularity</code></a></td><td>time granularity and for the shift</td><td><pre>&quot;months&quot;</pre></td></tr>
<tr><td><code>value</code></td><td><code>integer</code></td><td>the size of the step</td><td><pre>-1</pre></td></tr>
</tbody></table>
<h3 id="absolute"><a class="header" href="#absolute">Absolute</a></h3>
<p>If the <code>type</code> is <code>absolute</code>, you need to specify the following parameters:</p>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>timeInterval</code></td><td><a href="operators//datatypes/timeinterval.html"><code>TimeInterval</code></a></td><td>A fixed shift of the <a href="operators/./../datatypes/queryrectangle.html"><code>QueryRectangle</code>'s</a> time</td><td><pre><code>{<br>  &quot;start&quot;: &quot;2010-01-01T00:00:00Z&quot;,<br>  &quot;end&quot;: &quot;2010-02-01T00:00:00Z&quot;<br>}</code></pre></td></tr>
</tbody></table>
<h2 id="inputs-15"><a class="header" href="#inputs-15">Inputs</a></h2>
<p>The <code>TimeShift</code> operator expects either one <em>vector</em> input or one <em>raster</em> input.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>SingleRasterOrVectorSource</code></td></tr>
</tbody></table>
<h2 id="example-json-30"><a class="header" href="#example-json-30">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;TimeShift&quot;,
  &quot;params&quot;: {
    &quot;type&quot;: &quot;relative&quot;,
    &quot;granularity&quot;: &quot;months&quot;,
    &quot;value&quot;: -1
  },
  &quot;sources&quot;: {
    &quot;source&quot;: {
      &quot;type&quot;: &quot;GdalSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;TimeShift&quot;,
  &quot;params&quot;: {
    &quot;type&quot;: &quot;absolute&quot;,
    &quot;time_interval&quot;: {
      &quot;start&quot;: &quot;2010-01-01T00:00:00Z&quot;,
      &quot;end&quot;: &quot;2010-02-01T00:00:00Z&quot;
    }
  },
  &quot;sources&quot;: {
    &quot;source&quot;: {
      &quot;type&quot;: &quot;GdalSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector-expression"><a class="header" href="#vector-expression">Vector Expression</a></h1>
<p>The <code>VectorExpression</code> operator performs a feature-wise expression function on a feature collection of a vector source.
The expression is specified as a user-defined script in a very simple language.
The output is a feature collection with the result of the expression and with time intervals that are the same as for the inputs.
Users can either add a new column or replace the geometry column with the outputs of the expression.
Internally, the expression is evaluated using floating-point numbers.</p>
<p>An example usage scenario is to calculate a population density from an <code>area</code> and a <code>population_size</code> column.
The expression uses a feature collection with two columns, referred to with their column names <code>area</code> and a <code>population_size</code>, and calculates the formula <code>area / population_size</code>.
The output feature collection contains the result of the density expression in a new column.</p>
<p>Another example is to calculate the centroid of a polygon geometry.
The expression uses a feature collection with a geometry column and calculates the formula <code>centroid(geom)</code>.
The output feature collection contains the result of the centroid expression replacing the original geometries.</p>
<h2 id="parameters-18"><a class="header" href="#parameters-18">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>expression</code></td><td><code>Expression</code></td><td>Expression script</td><td><pre><code>area / population_size</code></pre></td></tr>
<tr><td><code>inputColumns</code></td><td><code>Vec&lt;String&gt;</code></td><td>The names of the attributes to generate boxes for.</td><td><pre><code>[<code>area</code>, <code>population_size</code>]</code></pre></td></tr>
<tr><td><code>outputColumn</code></td><td><code>OutputColumn</code></td><td>An output column name <em>or</em> a geometry type</td><td><pre><code>{&quot;type&quot;: &quot;column&quot;, &quot;value&quot;: &quot;density&quot;}</code> <code>{&quot;type&quot;: &quot;geometry&quot;, &quot;value&quot;: &quot;MultiPoint&quot;}</code></pre></td></tr>
<tr><td><code>geometryColumnName</code></td><td><code>String</code> (optional)</td><td>A name for the geometry variable. <code>geom</code> by default.</td><td><pre><code>geom</code></pre></td></tr>
<tr><td><code>outputMeasurement</code></td><td><a href="operators//datatypes/measurement.html"><code>Measurement</code></a></td><td>Description about the output</td><td><pre><code>{<br>  &quot;type&quot;: &quot;continuous&quot;,<br>  &quot;measurement&quot;: &quot;Density&quot;<br>}</code></pre></td></tr>
</tbody></table>
<p><em>Note:</em>
If a name in <code>inputColumns</code> contains any characters other than letters, numbers, and underscores, a canonical variable name has so be used in the expression.
For example, the column name <code>population size</code> has to be referred to as <code>population_size</code> in the expression.</p>
<h2 id="types-8"><a class="header" href="#types-8">Types</a></h2>
<p>The following describes the types used in the parameters.</p>
<h3 id="expression-1"><a class="header" href="#expression-1">Expression</a></h3>
<p>Expressions are simple scripts to perform feature-wise computations.
One can refer to the columns with their name, e.g., <code>area</code> and a <code>population_size</code>.
Furthermore, expressions can check with <code>A IS NODATA</code>, <code>B IS NODATA</code>, etc. for empty or NO DATA values.
Finally, the value <code>NODATA</code> can be used to output empty or NO DATA.</p>
<p>Users can think of this implicit function signature for, e.g., two inputs:</p>
<pre><code class="language-Rust">fn (A: f64, B: f64) -&gt; f64
</code></pre>
<p>As a start, expressions contain algebraic operations and mathematical functions.</p>
<pre><code class="language-Rust">(A + B) / 2
</code></pre>
<p>In addition, branches can be used to check for conditions.</p>
<pre><code class="language-Rust">if A IS NODATA {
    B
} else {
    A
}
</code></pre>
<p>To generate more complex expressions, it is possible to have variable assignments.</p>
<pre><code class="language-Rust">let mean = (A + B) / 2;
let coefficient = 0.357;
mean * coefficient
</code></pre>
<p>Note, that all assignments are separated by semicolons.
However, the last expression must be without a semicolon.</p>
<h4 id="numbers"><a class="header" href="#numbers">Numbers</a></h4>
<p>Function calls can be used to access utility functions.</p>
<pre><code class="language-Rust">max(A, 0)
</code></pre>
<p>Currently, the following functions are available:</p>
<ul>
<li><code>abs(a)</code>: absolute value</li>
<li><code>min(a, b)</code>, <code>min(a, b, c)</code>: minimum value</li>
<li><code>max(a, b)</code>, <code>max(a, b, c)</code>: maximum value</li>
<li><code>sqrt(a)</code>: square root</li>
<li><code>ln(a)</code>: natural logarithm</li>
<li><code>log10(a)</code>: base 10 logarithm</li>
<li><code>cos(a)</code>, <code>sin(a)</code>, <code>tan(a)</code>, <code>acos(a)</code>, <code>asin(a)</code>, <code>atan(a)</code>: trigonometric functions</li>
<li><code>pi()</code>, <code>e()</code>: mathematical constants</li>
<li><code>round(a)</code>, <code>ceil(a)</code>, <code>floor(a)</code>: rounding functions</li>
<li><code>mod(a, b)</code>: division remainder</li>
<li><code>to_degrees(a)</code>, <code>to_radians(a)</code>: conversion to degrees or radians</li>
</ul>
<h4 id="geometries"><a class="header" href="#geometries">Geometries</a></h4>
<p>Geometries can be referred to using the <code>geometryColumnName</code>, which is <code>geom</code> by default.
There are several functions to work with geometries:</p>
<ul>
<li><code>centroid(geom)</code>: returns the centroid of the geometry</li>
<li><code>area(geom)</code>: returns the area of the geometry</li>
</ul>
<p>An example expression to calculate the centroid of a geometry is:</p>
<pre><code class="language-Rust">centroid(geom)
</code></pre>
<h2 id="inputs-16"><a class="header" href="#inputs-16">Inputs</a></h2>
<p>The <code>VectorExpression</code> operator expects one rater input with at most 8 bands.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>vector</code></td><td><code>SingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-15"><a class="header" href="#errors-15">Errors</a></h2>
<p>The parsing of the expression can fail if there are, e.g., syntax errors.</p>
<h2 id="example-json-31"><a class="header" href="#example-json-31">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;VectorExpression&quot;,
  &quot;params&quot;: {
    &quot;inputColumns&quot;: [&quot;area&quot;, &quot;population_size&quot;],
    &quot;outputColumn&quot;: { &quot;type&quot;: &quot;column&quot;, &quot;value&quot;: &quot;density&quot; },
    &quot;expression&quot;: &quot;area /  population_size&quot;,
    &quot;outputMeasurement&quot;: { &quot;type&quot;: &quot;unitless&quot; }
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;areas&quot;
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;VectorExpression&quot;,
  &quot;params&quot;: {
    &quot;inputColumns&quot;: [],
    &quot;outputColumn&quot;: { &quot;type&quot;: &quot;geometry&quot;, &quot;value&quot;: &quot;MultiPoint&quot; },
    &quot;expression&quot;: &quot;centroid(geom)&quot;,
    &quot;geometryColumnName&quot;: &quot;geom&quot;
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;areas&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectorjoin"><a class="header" href="#vectorjoin">VectorJoin</a></h1>
<p>The <code>VectorJoin</code> operator allows combining multiple vector inputs into a single feature collection.
There are multiple join variants defined, which are described below.</p>
<p>For instance, you want to join tabular data to a point collection of buildings.
The point collection contains the geolocation of the buildings and their id.
The attribute data collection has the building id and the height information.
Combining the two feature collections leads to a single point collection with geolocation and height information.</p>
<h2 id="parameters-19"><a class="header" href="#parameters-19">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>type</code></td><td>A value of <code>EquiGeoToData</code>, …</td><td>The type of join</td><td><pre>&quot;EquiGeoToData&quot;</pre></td></tr>
</tbody></table>
<h3 id="equigeotodata"><a class="header" href="#equigeotodata">EquiGeoToData</a></h3>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>leftColumn</code></td><td>string</td><td>The column name of the left input</td><td><pre>&quot;id&quot;</pre></td></tr>
<tr><td><code>rightColumn</code></td><td>string</td><td>The column name of the right input</td><td><pre>&quot;id&quot;</pre></td></tr>
<tr><td><code>rightColumn_suffix</code></td><td>(Optional) string</td><td>A value to suffix the right join column to avoid name clashes with the columns of the left input. If nothing is specified, the default value is <code>right</code>.</td><td><pre>&quot;right&quot;</pre></td></tr>
</tbody></table>
<h2 id="inputs-17"><a class="header" href="#inputs-17">Inputs</a></h2>
<p>The <code>VectorJoin</code> operator expects two <em>vector</em> inputs.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>left</code></td><td><code>SingleVectorSource</code></td></tr>
<tr><td><code>right</code></td><td><code>SingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-16"><a class="header" href="#errors-16">Errors</a></h2>
<p>If the value in the <code>left</code> parameter is not a column of the left feature collection, an error is thrown.</p>
<p>If the value in the <code>right</code> parameter is not a column of the right feature collection, an error is thrown.</p>
<h3 id="equigeotodata-1"><a class="header" href="#equigeotodata-1">EquiGeoToData</a></h3>
<p>If the left input is not a geo data collection, an error is thrown.</p>
<p>If the right input is not a (non-geo) data collection, an error is thrown.</p>
<h2 id="example-json-32"><a class="header" href="#example-json-32">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;VectorJoin&quot;,
  &quot;params&quot;: {
    &quot;type&quot;: &quot;EquiGeoToData&quot;,
    &quot;leftColumn&quot;: &quot;id&quot;,
    &quot;rightColumn&quot;: &quot;id&quot;,
    &quot;rightColumnSuffix&quot;: &quot;_other&quot;
  },
  &quot;sources&quot;: {
    &quot;points&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;places&quot;,
        &quot;attributeProjection&quot;: [&quot;name&quot;, &quot;population&quot;]
      }
    },
    &quot;polygons&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;germany_outline&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visualpointclustering"><a class="header" href="#visualpointclustering">VisualPointClustering</a></h1>
<p>The <code>VisualPointClustering</code> is a clustering operator for point collections that removes clutter and preserves the spatial structure of the input.
The output is a point collection with a count and radius attribute.
The operator utilizes the input resolution of the query to determine when points, being displayed as circles, would overlap.
Moreover, it allows aggregating non-geo attributes to preserve the other columns of the input.
For more information on the algorithm, cf. the paper <a href="https://doi.org/10.1145/3139958.3140037">Beilschmidt, C. et al.: A Linear-Time Algorithm for the Aggregation and Visualization of Big Spatial Point Data. SIGSPATIAL/GIS 2017: 73:1-73:4</a>.</p>
<p>An exemplary use case for this operator is the visualization of point data in an online map application.
There, you can use this operator as the final step of the workflow to cluster the points and display them as circles.
These circles then pose a decluttered view of the data, e.g., via a WFS endpoint.</p>
<h2 id="parameters-20"><a class="header" href="#parameters-20">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>minRadiusPx</code></td><td>number</td><td>Minimum circle radius in screen pixels</td><td><pre>10</pre></td></tr>
<tr><td><code>deltaPx</code></td><td>number</td><td>Minimum circle to circle distance in screen pixels input</td><td><pre>1</pre></td></tr>
<tr><td><code>radiusColumn</code></td><td>string</td><td>The new column name to store radius information in screen pixels</td><td><pre>&quot;__radius&quot;</pre></td></tr>
<tr><td><code>countColumn</code></td><td>string</td><td>The new column name to store the number of points represented by each circle</td><td><pre>&quot;__count&quot;</pre></td></tr>
<tr><td><code>columnAggregates</code></td><td>Map from string to aggregate definition (one of <code>MeanNumber</code>, <code>StringSample</code> or <code>Null</code>)</td><td>Specify how miscellaneous columns should be aggregated. You can optionally set a new <a href="operators/../datatypes/measurement.html"><code>Measurement</code></a>. Otherwise, the <a href="operators/../datatypes/measurement.html"><code>Measurement</code></a> is taken from the source column.</td><td><pre><code>{<br>  &quot;foo&quot;: {<br>    &quot;columnName&quot;: &quot;numericColumn&quot;,<br>    &quot;aggregateType&quot;: &quot;MeanNumber&quot;,<br>    &quot;measurement&quot;: { &quot;type&quot;: &quot;unitless&quot; }<br>  },<br>  &quot;bar&quot;: {<br>    &quot;columnName&quot;: &quot;textColumn&quot;,<br>    &quot;aggregateType&quot;: &quot;StringSample&quot;<br>  }<br>}</code></pre></td></tr>
</tbody></table>
<h2 id="inputs-18"><a class="header" href="#inputs-18">Inputs</a></h2>
<p>The <code>VisualPointClustering</code> operator expects exactly one <em>vector</em> input that must be a point collection.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>vector</code></td><td><code>SingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-17"><a class="header" href="#errors-17">Errors</a></h2>
<p>If the source value <code>vector</code> is not a point collection, an error is thrown.</p>
<p>If multiple columns in <code>columnAggregates</code> have the same names, an error is thrown.</p>
<h2 id="example-json-33"><a class="header" href="#example-json-33">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;VisualPointClustering&quot;,
  &quot;params&quot;: {
    &quot;minRadiusPx&quot;: 8.0,
    &quot;deltaPx&quot;: 1.0,
    &quot;radiusColumn&quot;: &quot;__radius&quot;,
    &quot;countColumn&quot;: &quot;__count&quot;,
    &quot;columnAggregates&quot;: {
      &quot;mean_population&quot;: {
        &quot;columnName&quot;: &quot;population&quot;,
        &quot;aggregateType&quot;: &quot;MeanNumber&quot;,
        &quot;measurement&quot;: { &quot;type&quot;: &quot;unitless&quot; }
      },
      &quot;sample_names&quot;: {
        &quot;columnName&quot;: &quot;name&quot;,
        &quot;aggregateType&quot;: &quot;StringSample&quot;
      }
    }
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;places&quot;,
        &quot;attributeProjection&quot;: [&quot;name&quot;, &quot;population&quot;]
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plots"><a class="header" href="#plots">Plots</a></h1>
<p>Plots are special kinds of operators that generate visualizations.</p>
<p>Geo Engine supports three output types:</p>
<ul>
<li><code>jsonPlain</code>: structured output in JSON format</li>
<li><code>jsonVega</code>: a Vega-Lite visualization (cf. <a href="https://vega.github.io/vega-lite/">Vega-Lite</a>)</li>
<li><code>imagePng</code>: a PNG image</li>
</ul>
<p>Thus, plots can contain statistics, visualizations, and images.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boxplot"><a class="header" href="#boxplot">BoxPlot</a></h1>
<p>The <code>BoxPlot</code> is a <em>plot operator</em> that computes a box plot over</p>
<ul>
<li>a selection of numerical columns of a single vector dataset, or</li>
<li>multiple raster datasets.</li>
</ul>
<p>Thereby, the operator considers all data in the given query rectangle.</p>
<p>The boxes of the plot span the 1st and 3rd quartile and highlight the median. The whiskers indicate the minimum and maximum values of the corresponding attribute or raster.</p>
<h2 id="vector-data-1"><a class="header" href="#vector-data-1">Vector Data</a></h2>
<p>In the case of vector data, the operator generates one box for each of the selected numerical attributes.
The operator returns an error if one of the selected attributes is not numeric.</p>
<h3 id="parameter"><a class="header" href="#parameter">Parameter</a></h3>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>columnNames</code></td><td><code>Vec&lt;String&gt;</code></td><td>The names of the attributes to generate boxes for.</td><td><code>[&quot;x&quot;,&quot;y&quot;]</code></td></tr>
</tbody></table>
<h2 id="raster-data-1"><a class="header" href="#raster-data-1">Raster Data</a></h2>
<p>For raster data, the operator generates one box for each input raster.</p>
<h3 id="parameter-1"><a class="header" href="#parameter-1">Parameter</a></h3>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>columnNames</code></td><td><code>Vec&lt;String&gt;</code></td><td><em>Optional</em>: An alias for each input source. The operator will automatically name the boxes <code>Raster-1</code>, <code>Raster-2</code>, ... if this parameter is empty. If aliases are given, the number of aliases must match the number of input rasters. Otherwise an error is returned.</td><td><code>[&quot;A&quot;,&quot;B&quot;]</code>.</td></tr>
</tbody></table>
<h2 id="inputs-19"><a class="header" href="#inputs-19">Inputs</a></h2>
<p>The operator consumes exactly one <em>vector</em> or multiple <em>raster</em> operators.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>MultipleRasterOrSingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-18"><a class="header" href="#errors-18">Errors</a></h2>
<p>The operator returns an error in the following cases.</p>
<ul>
<li>Vector data: The <code>attribute</code> for one of the given <code>columnNames</code> is not numeric.</li>
<li>Vector data: The <code>attribute</code> for one of the given <code>columnNames</code> does not exist.</li>
<li>Raster data: The length of the <code>columnNames</code> parameter does not match the number of input rasters.</li>
</ul>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p>If your dataset contains <code>infinite</code> or <code>NAN</code> values, they are ignored for the computation. Moreover, if your dataset contains more than <code>10.000</code>values (which is likely for rasters),
the median and quartiles are estimated using the P^2 algorithm described in:</p>
<p>R. Jain and I. Chlamtac, The P^2 algorithm for dynamic calculation of quantiles and
histograms without storing observations, Communications of the ACM,
Volume 28 (October), Number 10, 1985, p. 1076-1085.
<a href="https://www.cse.wustl.edu/%7Ejain/papers/ftp/psqr.pdf">https://www.cse.wustl.edu/~jain/papers/ftp/psqr.pdf</a></p>
<h2 id="example-json-34"><a class="header" href="#example-json-34">Example JSON</a></h2>
<h3 id="vector"><a class="header" href="#vector">Vector</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;BoxPlot&quot;,
  &quot;params&quot;: {
    &quot;columnNames&quot;: [&quot;x&quot;, &quot;y&quot;]
  },
  &quot;sources&quot;: {
    &quot;source&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<h3 id="raster"><a class="header" href="#raster">Raster</a></h3>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;BoxPlot&quot;,
  &quot;params&quot;: {
    &quot;columnNames&quot;: [&quot;A&quot;, &quot;B&quot;]
  },
  &quot;sources&quot;: {
    &quot;source&quot;: [
      {
        &quot;type&quot;: &quot;GdalSource&quot;,
        &quot;params&quot;: {
          &quot;data&quot;: &quot;ndvi&quot;
        }
      },
      {
        &quot;type&quot;: &quot;GdalSource&quot;,
        &quot;params&quot;: {
          &quot;data&quot;: &quot;temperature&quot;
        }
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classhistogram"><a class="header" href="#classhistogram">ClassHistogram</a></h1>
<p>The <code>ClassHistogram</code> is a <em>plot operator</em> that computes a histogram plot either over categorical attributes of a vector dataset or categorical values of a raster source.
The output is a plot in <a href="https://vega.github.io/vega-lite/">Vega-Lite</a> specification.</p>
<p>For instance, you want to plot the frequencies of the classes of a categorical attribute of a feature collection.
Then you can use a class histogram to visualize and assess this.</p>
<h2 id="parameters-21"><a class="header" href="#parameters-21">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>columnName</code></td><td><code>string</code> (optional)</td><td>The name of the attribute making up the x-axis of the histogram. Must be set for a vector sources, must not be set for rasters.</td><td><code>&quot;temperature&quot;</code></td></tr>
</tbody></table>
<h2 id="inputs-20"><a class="header" href="#inputs-20">Inputs</a></h2>
<p>The operator consumes either one <em>vector</em> or one <em>raster</em> operator.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>SingleRasterOrVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-19"><a class="header" href="#errors-19">Errors</a></h2>
<p>The operator returns an error if…</p>
<ul>
<li>the selected column (<code>columnName</code>) does not exist or is not numeric,</li>
<li>the source is a raster and the property <code>columnName</code> is set, or</li>
<li>the input <a href="plots/../datatypes/measurement.html"><code>Measurement</code></a> is not categorical.</li>
</ul>
<p>The operator returns an error if</p>
<h2 id="notes-1"><a class="header" href="#notes-1">Notes</a></h2>
<p>The operator only uses values of the categorical <a href="plots/../datatypes/measurement.html"><code>Measurement</code></a>.
It ignores missing or no-data values and values that are not covered by the <a href="plots/../datatypes/measurement.html"><code>Measurement</code></a>.</p>
<h2 id="example-json-35"><a class="header" href="#example-json-35">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;ClassHistogram&quot;,
  &quot;params&quot;: {
    &quot;columnName&quot;: &quot;foobar&quot;
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="featureattributevaluesovertime"><a class="header" href="#featureattributevaluesovertime">FeatureAttributeValuesOverTime</a></h1>
<p>The <code>FeatureAttributeValuesOverTime</code> is a <em>plot operator</em> that computes a multi-line plot for feature attribute values over time.
For distinguishing features, the data requires an id column.
The output is a plot in Vega-Lite specification.</p>
<p><img src="plots/../images/feature_attribute_values_over_time_example.png" alt="Feature Attribute Values Over Time" /></p>
<p>For instance, you want to plot the NDVI values of a feature collection of trees.
Then, you can use a multi-line plot to visualize the trees by their id.</p>
<h2 id="parameters-22"><a class="header" href="#parameters-22">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>idColumn</code></td><td><code>string</code></td><td>The column name of the <code>id</code> attribute (one line per <code>id</code>.)</td><td><code>&quot;id&quot;</code></td></tr>
<tr><td><code>valueColumn</code></td><td><code>string</code></td><td>The column name of the <code>value</code> attribute (y-axis values).</td><td><code>&quot;temperature&quot;</code></td></tr>
</tbody></table>
<h2 id="inputs-21"><a class="header" href="#inputs-21">Inputs</a></h2>
<p>The operator consumes exactly one <em>vector</em> operator.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>vector</code></td><td><code>SingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-20"><a class="header" href="#errors-20">Errors</a></h2>
<p>The operator returns an error if the selected columns ( <code>idColumn</code> and <code>valueColumn</code>) do not exist or <code>valueColumn</code> is not numeric.</p>
<h2 id="notes-2"><a class="header" href="#notes-2">Notes</a></h2>
<p>The operator processes a maximum of <code>20</code> different ids.
After recognizing more than <code>20</code> different ids, the operator ignores the rest.</p>
<h2 id="example-json-36"><a class="header" href="#example-json-36">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;FeatureAttributeValuesOverTime&quot;,
  &quot;params&quot;: {
    &quot;idColumn&quot;: &quot;id&quot;,
    &quot;valueColumn&quot;: &quot;temperature&quot;
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="histogram"><a class="header" href="#histogram">Histogram</a></h1>
<p>The <code>Histogram</code> is a <em>plot operator</em> that computes a histogram plot either over attributes of a vector dataset or values of a raster source.
The output is a plot in <a href="https://vega.github.io/vega-lite/">Vega-Lite</a> specification.</p>
<p>For instance, you want to plot the data distribution of numeric attributes of a feature collection.
Then you can use a histogram with a suitable number of buckets to visualize and assess this.</p>
<h2 id="parameters-23"><a class="header" href="#parameters-23">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>columnName</code></td><td><code>string</code>, ignored for raster input</td><td>The name of the attribute making up the x-axis of the histogram.</td><td><code>&quot;temperature&quot;</code></td></tr>
<tr><td><code>bounds</code></td><td><code>HistogramBounds</code> (either <code>data</code> or specified <code>values</code>)</td><td>If <code>data</code>, it computes the bounds of the underlying data. If <code>values</code>, one can specify custom bounds.</td><td><pre><code>{<br>  &quot;min&quot;: 0.0,<br>  &quot;max&quot;: 20.0<br>}</code></pre> <code>&quot;data&quot;</code></td></tr>
<tr><td><code>buckets</code></td><td><code>Number</code> or <code>SquareRootChoiceRule</code></td><td>The number of buckets. The value can be specified or calculated.</td><td><pre><code>{<br>  &quot;type&quot;: &quot;number&quot;,<br>  &quot;value&quot;: 20<br>}</code></pre></td></tr>
<tr><td><code>interactive</code></td><td>(Optional) <code>boolean</code></td><td>Flag, if the histogram should have user interactions for a range selection. It is <code>false</code> by default.</td><td><code>true</code></td></tr>
</tbody></table>
<h2 id="inputs-22"><a class="header" href="#inputs-22">Inputs</a></h2>
<p>The operator consumes either one <em>vector</em> or one <em>raster</em> operator.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>SingleRasterOrVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-21"><a class="header" href="#errors-21">Errors</a></h2>
<p>The operator returns an error if the selected column (<code>columnName</code>) does not exist or is not numeric.</p>
<h2 id="notes-3"><a class="header" href="#notes-3">Notes</a></h2>
<p>If <code>bounds</code> or <code>buckets</code> are not defined, the operator will determine these values by itself which requires processing the data twice.</p>
<p>If the <code>buckets</code> parameter is set to <code>squareRootChoiceRule</code>, the operator estimates it using the square root of the number of elements in the data.</p>
<h2 id="example-json-37"><a class="header" href="#example-json-37">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Histogram&quot;,
  &quot;params&quot;: {
    &quot;columnName&quot;: &quot;foobar&quot;,
    &quot;bounds&quot;: {
      &quot;min&quot;: 5.0,
      &quot;max&quot;: 10.0
    },
    &quot;buckets&quot;: {
      &quot;type&quot;: &quot;number&quot;,
      &quot;value&quot;: 15
    },
    &quot;interactive&quot;: false
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meanrasterpixelvaluesovertime"><a class="header" href="#meanrasterpixelvaluesovertime">MeanRasterPixelValuesOverTime</a></h1>
<p>The <code>MeanRasterPixelValuesOverTime</code> is a <em>plot operator</em> that computes a time series plot of mean raster values.
For each time step in the raster time series, it computes one mean value.
The output is a plot in Vega-Lite specification.</p>
<p>For instance, you want to plot the mean temperature of a monthly raster time series.
Then, you can use this operator to generate a time series plot.</p>
<h2 id="parameters-24"><a class="header" href="#parameters-24">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>timePosition</code></td><td>string (<code>start</code>, <code>center</code> or <code>end</code>)</td><td>Where should the x-axis (time) tick be positioned? At either time start, time end or in the center.</td><td><code>&quot;start&quot;</code></td></tr>
<tr><td><code>area</code></td><td>(Optional) <code>boolean</code></td><td>Whether to fill the area under the curve. Defaults to <code>true</code>.</td><td><code>false</code></td></tr>
</tbody></table>
<h2 id="inputs-23"><a class="header" href="#inputs-23">Inputs</a></h2>
<p>The operator consumes exactly one <em>raster</em> operator.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>raster</code></td><td><code>SingleRasterSource</code></td></tr>
</tbody></table>
<h2 id="example-json-38"><a class="header" href="#example-json-38">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;MeanRasterPixelValuesOverTime&quot;,
  &quot;params&quot;: {
    &quot;timePosition&quot;: &quot;start&quot;,
    &quot;area&quot;: true
  },
  &quot;sources&quot;: {
    &quot;raster&quot;: {
      &quot;type&quot;: &quot;GdalSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="piechart"><a class="header" href="#piechart">PieChart</a></h1>
<p>The <code>PieChart</code> is a <em>plot operator</em> that computes a pie chart for a given vector dataset.
Moreover, the operator considers all data in the given query rectangle.</p>
<p>There are multiple variants on how to compute the slices of the pie chart.
In addition, it is possible to compute a donut chart instead of a standard pie chart.</p>
<h2 id="parameters-25"><a class="header" href="#parameters-25">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>type</code></td><td>Pie Chart Type</td><td>The type of aggregation that is used to create the slices of the pie chart.</td><td><code>&quot;count&quot;</code></td></tr>
<tr><td><code>columnName</code></td><td><code>String</code></td><td>The names of the attribute to generate pies for.</td><td><code>&quot;name&quot;</code></td></tr>
</tbody></table>
<h3 id="pie-chart-type"><a class="header" href="#pie-chart-type">Pie Chart Type</a></h3>
<p>The <code>type</code> parameter can be one of the following values:</p>
<ul>
<li><code>count</code>: Creates one slice for each distinct value in the given column <code>columnName</code>.
Then, it counts the number of occurrences.</li>
</ul>
<h2 id="inputs-24"><a class="header" href="#inputs-24">Inputs</a></h2>
<p>The operator consumes exactly one <em>vector</em> operator.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>vector</code></td><td><code>SingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-22"><a class="header" href="#errors-22">Errors</a></h2>
<p>The operator returns an error in the following cases.</p>
<ul>
<li>The <code>attribute</code> for the given <code>columnName</code> does not exist.</li>
<li>The number of slices is too large: If the number of slices is greater than <code>32</code>, the operator returns an error.</li>
</ul>
<h2 id="notes-4"><a class="header" href="#notes-4">Notes</a></h2>
<p>If the attribute has a <a href="plots//datatypes/measurement.html#classification"><code>Measurement</code></a> of type <code>Classification</code>, the operator uses the class name instead of the raw value.</p>
<h2 id="example-json-39"><a class="header" href="#example-json-39">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;PieChart&quot;,
  &quot;params&quot;: {
    &quot;type&quot;: &quot;count&quot;,
    &quot;columnName&quot;: &quot;name&quot;,
    &quot;donut&quot;: false
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scatterplot"><a class="header" href="#scatterplot">ScatterPlot</a></h1>
<p>The <code>ScatterPlot</code> is a <em>plot operator</em> that computes a scatter plot over two attributes of a vector dataset.
Thereby, the operator considers all data in the given query rectangle.</p>
<p>In case of more than <code>500</code> points to plot, the representation changes from a regular scatter plot
to a 2D Histogram with buckets determined from the underlying data.</p>
<h2 id="parameters-26"><a class="header" href="#parameters-26">Parameters</a></h2>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>columnX</code></td><td><code>String</code></td><td>The name of the attribute making up the x-axis of the plot.</td><td><code>&quot;width&quot;</code></td></tr>
<tr><td><code>columnY</code></td><td><code>String</code></td><td>The name of the attribute making up the y-axis of the plot.</td><td><code>&quot;height&quot;</code></td></tr>
</tbody></table>
<h2 id="inputs-25"><a class="header" href="#inputs-25">Inputs</a></h2>
<p>The operator consumes exactly one <em>vector</em> operator.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>SingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-23"><a class="header" href="#errors-23">Errors</a></h2>
<p>The operator returns an error if one of the selected columns does not exist or is not numeric.</p>
<h2 id="notes-5"><a class="header" href="#notes-5">Notes</a></h2>
<p>If your dataset contains <code>infinite</code> or <code>NAN</code> values, they are ignored for the computation. Moreover, if
your dataset contains more than <code>10.000</code> values, the buckets of the histogram are generated based on
those <code>10.000</code> values. Later values outside those bounds are ignored.</p>
<h2 id="example-json-40"><a class="header" href="#example-json-40">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;ScatterPlot&quot;,
  &quot;params&quot;: {
    &quot;columnX&quot;: &quot;width&quot;,
    &quot;columnY&quot;: &quot;height&quot;
  },
  &quot;sources&quot;: {
    &quot;vector&quot;: {
      &quot;type&quot;: &quot;OgrSource&quot;,
      &quot;params&quot;: {
        &quot;data&quot;: &quot;ndvi&quot;
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statistics"><a class="header" href="#statistics">Statistics</a></h1>
<p>The <code>Statistics</code> operator is a <em>plot operator</em> that computes count statistics over</p>
<ul>
<li>a selection of numerical columns of a single vector dataset, or</li>
<li>multiple raster datasets.</li>
</ul>
<p>The output is a JSON description.</p>
<p>For instance, you want to get an overview of a raster data source.
Then, you can use this operator to get basic count statistics.</p>
<h2 id="vector-data-2"><a class="header" href="#vector-data-2">Vector Data</a></h2>
<p>In the case of vector data, the operator generates one statistic for each of the selected numerical attributes.
The operator returns an error if one of the selected attributes is not numeric.</p>
<h3 id="parameter-2"><a class="header" href="#parameter-2">Parameter</a></h3>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>columnNames</code></td><td><code>Vec&lt;String&gt;</code></td><td>The names of the attributes to generate statistics for.</td><td><code>[&quot;x&quot;,&quot;y&quot;]</code></td></tr>
</tbody></table>
<h2 id="raster-data-2"><a class="header" href="#raster-data-2">Raster Data</a></h2>
<p>For raster data, the operator generates one statistic for each input raster.</p>
<h3 id="parameter-3"><a class="header" href="#parameter-3">Parameter</a></h3>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th><th>Example Value</th></tr></thead><tbody>
<tr><td><code>columnNames</code></td><td><code>Vec&lt;String&gt;</code></td><td><em>Optional</em>: An alias for each input source. The operator will automatically name the rasters <code>Raster-1</code>, <code>Raster-2</code>, ... if this parameter is empty. If aliases are given, the number of aliases must match the number of input rasters. Otherwise an error is returned.</td><td><code>[&quot;A&quot;,&quot;B&quot;]</code>.</td></tr>
</tbody></table>
<h2 id="inputs-26"><a class="header" href="#inputs-26">Inputs</a></h2>
<p>The operator consumes exactly one <em>vector</em> or multiple <em>raster</em> operators.</p>
<table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody>
<tr><td><code>source</code></td><td><code>MultipleRasterOrSingleVectorSource</code></td></tr>
</tbody></table>
<h2 id="errors-24"><a class="header" href="#errors-24">Errors</a></h2>
<p>The operator returns an error in the following cases.</p>
<ul>
<li>Vector data: The <code>attribute</code> for one of the given <code>columnNames</code> is not numeric.</li>
<li>Vector data: The <code>attribute</code> for one of the given <code>columnNames</code> does not exist.</li>
<li>Raster data: The length of the <code>columnNames</code> parameter does not match the number of input rasters.</li>
</ul>
<h2 id="example-json-41"><a class="header" href="#example-json-41">Example JSON</a></h2>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Statistics&quot;,
  &quot;params&quot;: {
    &quot;columnNames&quot;: [&quot;A&quot;]
  },
  &quot;sources&quot;: {
    &quot;source&quot;: [
      {
        &quot;type&quot;: &quot;GdalSource&quot;,
        &quot;params&quot;: {
          &quot;data&quot;: &quot;ndvi&quot;
        }
      }
    ]
  }
}
</code></pre>
<h3 id="example-output"><a class="header" href="#example-output">Example Output</a></h3>
<pre><code class="language-json">{
  &quot;A&quot;: {
    &quot;valueCount&quot;: 6,
    &quot;validCount&quot;: 6,
    &quot;min&quot;: 1.0,
    &quot;max&quot;: 6.0,
    &quot;mean&quot;: 3.5,
    &quot;stddev&quot;: 1.707
  }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
